{"file_contents":{"README.md":{"content":"# 🏎️ Track.lytix - Professional F1 Data Analysis Platform\n\n[![Python](https://img.shields.io/badge/Python-3.11+-blue.svg)](https://python.org)\n[![FastF1](https://img.shields.io/badge/FastF1-3.6.0-green.svg)](https://github.com/theOehrly/Fast-F1)\n[![Streamlit](https://img.shields.io/badge/Streamlit-1.39+-red.svg)](https://streamlit.io)\n[![Next.js](https://img.shields.io/badge/Next.js-14+-black.svg)](https://nextjs.org)\n[![TypeScript](https://img.shields.io/badge/TypeScript-5.3+-blue.svg)](https://typescriptlang.org)\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)\n\n> **Track.lytix** is a comprehensive Formula 1 data analysis platform that provides advanced race data visualization and analytics capabilities. Built with modern web technologies and professional-grade design.\n\n## ✨ Features\n\n### 🔧 Core Analytics\n- **Real-time Telemetry Analysis** - Speed, throttle, brake, RPM, and gear data visualization\n- **Advanced Performance Metrics** - Comprehensive driver and team comparison tools\n- **Brake Analysis System** - Efficiency, force analysis, and duration tracking\n- **Composite Performance Index** - Multi-factor performance evaluation combining speed, acceleration, and efficiency\n- **Tire Strategy Visualization** - Compound performance analysis with degradation tracking\n- **Track Dominance Mapping** - Sector-by-sector performance visualization\n- **Weather Impact Analysis** - Correlation between weather conditions and performance\n- **Race Strategy Analytics** - Pit stop strategy and pace evolution tracking\n\n### 🎨 Modern Interface\n- **Dual Interface Options** - Traditional Streamlit and modern Next.js/TypeScript frontend\n- **Professional Design** - High-contrast F1-themed styling with glass morphism effects\n- **Responsive Layout** - Mobile-first design with dynamic tab system\n- **Interactive Visualizations** - Plotly-powered charts with professional styling\n- **Real-time Data Updates** - Live session data loading and caching\n\n### 🚀 Technical Stack\n- **Backend**: Python 3.11+, FastAPI, FastF1 library\n- **Frontend**: Next.js 14, TypeScript, Tailwind CSS, Framer Motion\n- **Legacy Interface**: Streamlit with custom CSS styling\n- **Data Visualization**: Plotly, Recharts\n- **Data Processing**: Pandas, NumPy, SciPy\n- **API**: RESTful endpoints with automatic OpenAPI documentation\n\n## 🛠️ Installation & Setup\n\n### Prerequisites\n- Python 3.11 or higher\n- Node.js 18+ (for Next.js frontend)\n- Git\n\n### Quick Start with Replit\n1. **Fork this repository** on Replit\n2. **Install dependencies** automatically via Replit's package manager\n3. **Run the application** using the configured workflows\n\n### Local Development Setup\n\n#### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-username/track-lytix.git\ncd track-lytix\n```\n\n#### 2. Set Up Python Environment\n```bash\n# Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n\n# Install Python dependencies\npip install -r requirements.txt\n```\n\n#### 3. Install Node.js Dependencies (for Next.js frontend)\n```bash\ncd frontend-next\nnpm install\ncd ..\n```\n\n#### 4. Configure Environment\nCreate a `.streamlit/config.toml` file:\n```toml\n[server]\nheadless = true\naddress = \"0.0.0.0\"\nport = 5000\n\n[theme]\nbase = \"dark\"\n```\n\n## 🚀 Running the Application\n\n### Option 1: Command Line Launch (Easiest)\n```bash\n# Simply run the main script - handles everything automatically\npython main.py\n```\nThis will:\n- Check all dependencies\n- Create Streamlit configuration\n- Launch Track.lytix on `http://localhost:5000`\n\n### Option 2: Direct Streamlit Interface\n```bash\n# Run the traditional Streamlit interface\nstreamlit run app.py --server.port 5000 --server.address 0.0.0.0\n```\nAccess at: `http://localhost:5000`\n\n### Option 2: Modern Web Frontend + API Backend\n```bash\n# Terminal 1: Start the FastAPI backend\npython api_server.py\n\n# Terminal 2: Start the Next.js frontend\ncd frontend-next\nnpm run dev\n```\n- API Documentation: `http://localhost:8000/api/docs`\n- Frontend Application: `http://localhost:3000`\n\n### Option 3: Full Stack Development\n```bash\n# Run all services simultaneously (recommended for development)\n# Use the configured Replit workflows or run manually:\n\n# Terminal 1: Streamlit\nstreamlit run app.py --server.port 5000 --server.address 0.0.0.0\n\n# Terminal 2: FastAPI Backend\npython api_server.py\n\n# Terminal 3: Next.js Frontend\ncd frontend-next && npm run dev\n```\n\n## 📊 Usage Guide\n\n### Getting Started\n1. **Select Session Data**:\n   - Choose year (2018-2025)\n   - Select Grand Prix event\n   - Pick session type (Practice, Qualifying, Race, Sprint)\n\n2. **Load Data**: Click \"Load Session Data\" to fetch telemetry information\n\n3. **Choose Drivers**: Select drivers for comparison analysis\n\n4. **Explore Analytics**:\n   - **Telemetry**: Speed, throttle, brake, and gear analysis\n   - **Lap Analysis**: Sector times and lap progression\n   - **Tire Strategy**: Compound performance and pit stop analysis\n   - **Track Dominance**: Fastest sectors visualization\n   - **Advanced Analytics**: Performance index and ML clustering\n   - **Brake Analysis**: Efficiency and force metrics\n   - **Composite Performance**: Multi-factor driver evaluation\n\n### Advanced Features\n- **Data Export**: Download charts and analysis data\n- **Real-time Updates**: Live session data refresh\n- **Professional Styling**: High-contrast design for better visibility\n- **Mobile Support**: Responsive design for all devices\n\n## 🔧 API Documentation\n\n### Core Endpoints\n- `POST /api/session/load` - Load F1 session data\n- `GET /api/drivers` - Get available drivers\n- `POST /api/analysis/telemetry` - Telemetry analysis\n- `POST /api/analysis/brake` - Brake performance analysis\n- `POST /api/analysis/composite` - Composite performance metrics\n- `POST /api/analysis/tire` - Tire strategy analysis\n- `GET /api/constants/teams` - Team colors and constants\n\n### Example API Usage\n```python\nimport requests\n\n# Load session data\nresponse = requests.post(\"http://localhost:8000/api/session/load\", json={\n    \"year\": 2024,\n    \"grand_prix\": \"Monaco\",\n    \"session_type\": \"R\"\n})\n\n# Get brake analysis\nresponse = requests.post(\"http://localhost:8000/api/analysis/brake\", json={\n    \"drivers\": [\"VER\", \"HAM\", \"LEC\"]\n})\n```\n\n## 📁 Project Structure\n\n```\ntrack-lytix/\n├── app.py                      # Main Streamlit application\n├── api_server.py               # FastAPI backend server\n├── requirements.txt            # Python dependencies\n├── replit.md                   # Project documentation\n├── \n├── utils/                      # Core analysis modules\n│   ├── data_loader.py          # F1 data loading and caching\n│   ├── brake_analysis.py       # Brake efficiency analysis\n│   ├── composite_performance.py # Performance index calculations\n│   ├── advanced_analytics.py   # ML-powered analytics\n│   ├── tire_performance.py     # Tire strategy analysis\n│   ├── visualizations.py       # Plotly chart generation\n│   ├── constants.py            # F1 team colors and data\n│   └── ...                     # Additional analysis modules\n├── \n├── frontend-next/              # Next.js TypeScript frontend\n│   ├── app/                    # Next.js 14 app directory\n│   │   ├── components/         # React components\n│   │   ├── globals.css         # Global styles\n│   │   ├── layout.tsx          # Root layout\n│   │   └── page.tsx            # Main page\n│   ├── package.json            # Node.js dependencies\n│   ├── tailwind.config.js      # Tailwind CSS configuration\n│   └── next.config.js          # Next.js configuration\n└── \n└── .streamlit/                 # Streamlit configuration\n    └── config.toml             # Server settings\n```\n\n## 🎨 Customization\n\n### Styling\n- Modify `app.py` CSS variables for color themes\n- Update `frontend-next/tailwind.config.js` for frontend styling\n- Customize team colors in `utils/constants.py`\n\n### Adding New Analysis\n1. Create new module in `utils/` directory\n2. Add corresponding API endpoint in `api_server.py`\n3. Import and integrate in `app.py`\n4. Add frontend component in `frontend-next/app/components/`\n\n## 🤝 Contributing\n\n1. Fork the repository\n2. Create a feature branch: `git checkout -b feature/new-analysis`\n3. Commit changes: `git commit -am 'Add new analysis feature'`\n4. Push to branch: `git push origin feature/new-analysis`\n5. Submit a Pull Request\n\n## 📄 License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## 🙏 Acknowledgments\n\n- **FastF1** - Official F1 data access library\n- **Streamlit** - Web application framework\n- **Next.js** - React framework for production\n- **Plotly** - Interactive visualization library\n- **Formula 1** - For providing official timing data\n\n## 📞 Support\n\n- **Issues**: [GitHub Issues](https://github.com/your-username/track-lytix/issues)\n- **Documentation**: [Project Wiki](https://github.com/your-username/track-lytix/wiki)\n- **API Docs**: `http://localhost:8000/api/docs` (when running)\n\n---\n\n<div align=\"center\">\n  <h3>🏎️ Built for F1 Enthusiasts, by F1 Enthusiasts</h3>\n  <p>Track.lytix - Professional Formula 1 Data Analysis Platform</p>\n</div>","size_bytes":9410},"app.py":{"content":"import streamlit as st\nimport fastf1\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport os\nimport tempfile\nfrom datetime import datetime\n\n# Import utility modules\nfrom utils.data_loader import DataLoader\nfrom utils.visualizations import create_telemetry_plot, create_tire_strategy_plot, create_race_progression_plot\nfrom utils.track_dominance import create_track_dominance_map\nfrom utils.constants import TEAM_COLORS, DRIVER_TEAMS, GRANDS_PRIX, SESSIONS, TIRE_COLORS\nfrom utils.formatters import format_lap_time, format_sector_time, get_lap_time_color_class, get_position_change_text, format_average_lap_time\nfrom utils.advanced_analytics import AdvancedF1Analytics\nfrom utils.weather_analytics import WeatherAnalytics\nfrom utils.race_strategy import RaceStrategyAnalyzer\nfrom utils.tire_performance import TirePerformanceAnalyzer\nfrom utils.stress_index import DriverStressAnalyzer\nfrom utils.downforce_analysis import DownforceAnalyzer\nfrom utils.driver_manager import DynamicDriverManager\nfrom utils.enhanced_analytics import EnhancedF1Analytics\nfrom utils.brake_analysis import BrakeAnalyzer\nfrom utils.composite_performance import CompositePerformanceAnalyzer\n\n# Configure page\nst.set_page_config(\n    page_title=\"Track.lytix - F1 Analytics\",\n    page_icon=\"🏎️\",\n    layout=\"wide\",\n    initial_sidebar_state=\"collapsed\"\n)\n\n# Professional minimal styling\nst.markdown(\"\"\"\n<style>\n    /* Import professional fonts */\n    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');\n    \n    /* Global reset and base styles */\n    * {\n        font-family: 'Inter', sans-serif;\n    }\n    \n    /* Root variables */\n    :root {\n        --primary-color: #1f2937;\n        --secondary-color: #374151;\n        --accent-color: #dc2626;\n        --text-primary: #111827;\n        --text-secondary: #6b7280;\n        --bg-light: #f9fafb;\n        --bg-white: #ffffff;\n        --border-color: #e5e7eb;\n        --success-color: #059669;\n        --warning-color: #d97706;\n        --radius: 8px;\n        --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n    }\n    \n    /* Main container */\n    .main .block-container {\n        background-color: var(--bg-light);\n        padding: 2rem 1rem;\n        max-width: 1200px;\n        margin: 0 auto;\n    }\n    \n    /* Header styles */\n    .header-container {\n        background: var(--bg-white);\n        padding: 2rem;\n        border-radius: var(--radius);\n        box-shadow: var(--shadow);\n        margin-bottom: 2rem;\n        text-align: center;\n        border-left: 4px solid var(--accent-color);\n    }\n    \n    .header-title {\n        font-size: 2.5rem;\n        font-weight: 700;\n        color: var(--text-primary);\n        margin: 0;\n        margin-bottom: 0.5rem;\n    }\n    \n    .header-subtitle {\n        font-size: 1.1rem;\n        color: var(--text-secondary);\n        font-weight: 400;\n        margin: 0;\n    }\n    \n    /* Card styles */\n    .card {\n        background: var(--bg-white);\n        border-radius: var(--radius);\n        padding: 1.5rem;\n        box-shadow: var(--shadow);\n        margin-bottom: 1.5rem;\n        border: 1px solid var(--border-color);\n    }\n    \n    .card-header {\n        font-size: 1.25rem;\n        font-weight: 600;\n        color: var(--text-primary);\n        margin-bottom: 1rem;\n        padding-bottom: 0.75rem;\n        border-bottom: 1px solid var(--border-color);\n    }\n    \n    /* Driver card */\n    .driver-card {\n        background: var(--bg-white);\n        border: 1px solid var(--border-color);\n        border-radius: var(--radius);\n        padding: 1rem;\n        margin: 0.5rem 0;\n        transition: all 0.2s ease;\n        text-align: center;\n    }\n    \n    .driver-card:hover {\n        box-shadow: var(--shadow-lg);\n        transform: translateY(-1px);\n    }\n    \n    .driver-name {\n        font-weight: 600;\n        font-size: 1.1rem;\n        color: var(--text-primary);\n    }\n    \n    .driver-team {\n        font-size: 0.9rem;\n        color: var(--text-secondary);\n        margin-top: 0.25rem;\n    }\n    \n    .driver-number {\n        font-size: 0.8rem;\n        color: var(--text-secondary);\n        margin-top: 0.25rem;\n    }\n    \n    /* Session controls */\n    .session-controls {\n        background: var(--bg-white);\n        border-radius: var(--radius);\n        padding: 1.5rem;\n        box-shadow: var(--shadow);\n        margin-bottom: 2rem;\n        border: 1px solid var(--border-color);\n    }\n    \n    /* Tabs styling */\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 4px;\n        background: var(--bg-white);\n        padding: 0.5rem;\n        border-radius: var(--radius);\n        border: 1px solid var(--border-color);\n        margin-bottom: 1.5rem;\n    }\n    \n    .stTabs [data-baseweb=\"tab\"] {\n        height: 50px;\n        background: transparent;\n        border-radius: calc(var(--radius) - 2px);\n        color: var(--text-secondary);\n        font-weight: 500;\n        font-size: 0.9rem;\n        border: none;\n        padding: 0 1.5rem;\n        transition: all 0.2s ease;\n    }\n    \n    .stTabs [data-baseweb=\"tab\"]:hover {\n        background: var(--bg-light);\n        color: var(--text-primary);\n    }\n    \n    .stTabs [aria-selected=\"true\"] {\n        background: var(--accent-color);\n        color: white;\n        font-weight: 600;\n    }\n    \n    /* Button styling */\n    .stButton > button {\n        background: var(--accent-color);\n        color: white;\n        border: none;\n        border-radius: var(--radius);\n        padding: 0.6rem 1.5rem;\n        font-weight: 500;\n        font-size: 0.9rem;\n        transition: all 0.2s ease;\n        box-shadow: var(--shadow);\n    }\n    \n    .stButton > button:hover {\n        background: #b91c1c;\n        box-shadow: var(--shadow-lg);\n        transform: translateY(-1px);\n    }\n    \n    /* Select box styling */\n    .stSelectbox > div > div {\n        background-color: var(--bg-white);\n        border: 1px solid var(--border-color);\n        border-radius: var(--radius);\n        font-size: 0.9rem;\n    }\n    \n    .stMultiSelect > div > div {\n        background-color: var(--bg-white);\n        border: 1px solid var(--border-color);\n        border-radius: var(--radius);\n        font-size: 0.9rem;\n    }\n    \n    /* Data table styling */\n    .stDataFrame {\n        background: var(--bg-white);\n        border: 1px solid var(--border-color);\n        border-radius: var(--radius);\n        overflow: hidden;\n        box-shadow: var(--shadow);\n    }\n    \n    .stDataFrame thead tr th {\n        background: var(--primary-color);\n        color: white;\n        font-weight: 600;\n        text-align: center;\n        padding: 1rem 0.5rem;\n        border: none;\n        font-size: 0.9rem;\n    }\n    \n    .stDataFrame tbody tr td {\n        text-align: center;\n        padding: 0.75rem 0.5rem;\n        border-bottom: 1px solid var(--border-color);\n        color: var(--text-primary);\n        font-size: 0.85rem;\n    }\n    \n    .stDataFrame tbody tr:hover td {\n        background: var(--bg-light);\n    }\n    \n    /* Metrics styling */\n    .metric-grid {\n        display: grid;\n        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n        gap: 1rem;\n        margin: 1rem 0;\n    }\n    \n    .metric-card {\n        background: var(--bg-white);\n        border: 1px solid var(--border-color);\n        border-radius: var(--radius);\n        padding: 1.25rem;\n        text-align: center;\n        box-shadow: var(--shadow);\n    }\n    \n    .metric-value {\n        font-size: 1.5rem;\n        font-weight: 700;\n        color: var(--accent-color);\n        margin-bottom: 0.25rem;\n    }\n    \n    .metric-label {\n        font-size: 0.85rem;\n        color: var(--text-secondary);\n        font-weight: 500;\n    }\n    \n    /* Status indicators */\n    .status-success {\n        color: var(--success-color);\n    }\n    \n    .status-warning {\n        color: var(--warning-color);\n    }\n    \n    .status-error {\n        color: var(--accent-color);\n    }\n    \n    /* Loading states */\n    .stSpinner > div {\n        border-color: var(--accent-color);\n    }\n    \n    /* Info messages */\n    .stAlert {\n        border-radius: var(--radius);\n        border: 1px solid var(--border-color);\n    }\n    \n    /* Mobile responsive */\n    @media (max-width: 768px) {\n        .main .block-container {\n            padding: 1rem 0.5rem;\n        }\n        \n        .header-title {\n            font-size: 2rem;\n        }\n        \n        .card {\n            padding: 1rem;\n        }\n        \n        .stTabs [data-baseweb=\"tab\"] {\n            padding: 0 1rem;\n            font-size: 0.8rem;\n        }\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# Initialize session state\nif 'data_loader' not in st.session_state:\n    st.session_state.data_loader = DataLoader()\n\ndef main():\n    \"\"\"Main application function\"\"\"\n    \n    # Header\n    st.markdown(\"\"\"\n    <div class=\"header-container\">\n        <h1 class=\"header-title\">🏎️ Track.lytix</h1>\n        <p class=\"header-subtitle\">Professional Formula 1 Data Analysis Platform</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Session controls\n    st.markdown('<div class=\"session-controls\">', unsafe_allow_html=True)\n    st.markdown('<div class=\"card-header\">📊 Session Configuration</div>', unsafe_allow_html=True)\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        year = st.selectbox(\n            \"Season\",\n            options=list(range(2024, 2017, -1)),\n            index=0,\n            help=\"Select F1 season year\"\n        )\n    \n    with col2:\n        selected_gp = st.selectbox(\n            \"Grand Prix\",\n            options=GRANDS_PRIX,\n            index=0,\n            help=\"Select Grand Prix event\"\n        )\n    \n    with col3:\n        session_type = st.selectbox(\n            \"Session\",\n            options=list(SESSIONS.keys()),\n            index=2,  # Default to Qualifying\n            help=\"Select session type\"\n        )\n    \n    # Load session button\n    if st.button(\"🔄 Load Session Data\", type=\"primary\"):\n        with st.spinner(\"Loading F1 session data...\"):\n            try:\n                success = st.session_state.data_loader.load_session(\n                    year, selected_gp, SESSIONS[session_type]\n                )\n                if success:\n                    st.success(f\"✅ Successfully loaded {year} {selected_gp} {session_type}\")\n                else:\n                    st.error(\"❌ Failed to load session data\")\n            except Exception as e:\n                st.error(f\"❌ Error loading session: {str(e)}\")\n    \n    st.markdown('</div>', unsafe_allow_html=True)\n    \n    # Driver selection\n    selected_drivers = []\n    if hasattr(st.session_state.data_loader, 'session') and st.session_state.data_loader.session is not None:\n        st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n        st.markdown('<div class=\"card-header\">🏁 Driver Selection</div>', unsafe_allow_html=True)\n        \n        # Get driver information\n        driver_manager = DynamicDriverManager(st.session_state.data_loader.session)\n        driver_info = driver_manager.get_driver_info()\n        team_mappings = driver_manager.get_team_mappings()\n        team_colors = driver_manager.get_team_colors()\n        \n        available_drivers = list(driver_info.keys())\n        \n        if available_drivers:\n            selected_drivers = st.multiselect(\n                \"Select drivers for analysis\",\n                available_drivers,\n                default=[],\n                format_func=lambda x: f\"{driver_info[x]['abbreviation']} - {driver_info[x]['team_name']}\",\n                help=\"Choose 2-4 drivers for optimal comparison\"\n            )\n            \n            # Display selected drivers\n            if selected_drivers:\n                st.markdown(\"**Selected Drivers:**\")\n                driver_cols = st.columns(min(len(selected_drivers), 4))\n                \n                for idx, driver in enumerate(selected_drivers):\n                    with driver_cols[idx % 4]:\n                        driver_data = driver_info[driver]\n                        team_name = driver_data['team_name']\n                        team_color = team_colors.get(team_name, '#6b7280')\n                        \n                        st.markdown(f\"\"\"\n                        <div class=\"driver-card\" style=\"border-left: 3px solid {team_color};\">\n                            <div class=\"driver-name\">{driver_data['abbreviation']}</div>\n                            <div class=\"driver-team\">{team_name}</div>\n                            <div class=\"driver-number\">#{driver_data.get('driver_number', 'N/A')}</div>\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n            else:\n                st.info(\"👆 Select drivers above to begin analysis\")\n        else:\n            st.warning(\"No drivers available in this session\")\n        \n        st.markdown('</div>', unsafe_allow_html=True)\n    else:\n        st.info(\"⬆️ Load session data first to select drivers\")\n    \n    # Analysis tabs\n    if selected_drivers and hasattr(st.session_state.data_loader, 'session'):\n        tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([\n            \"📈 Telemetry\",\n            \"🗺️ Track Map\", \n            \"⏱️ Lap Times\",\n            \"🔧 Tire Strategy\",\n            \"📊 Race Progress\",\n            \"🧠 Advanced Analytics\"\n        ])\n        \n        with tab1:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">📈 Telemetry Analysis</div>', unsafe_allow_html=True)\n            \n            telemetry_type = st.selectbox(\n                \"Telemetry Parameter\",\n                [\"Speed\", \"Throttle\", \"Brake\", \"RPM\", \"Gear\"],\n                help=\"Select telemetry data to analyze\"\n            )\n            \n            with st.spinner(\"Generating telemetry visualization...\"):\n                try:\n                    fig = create_telemetry_plot(\n                        st.session_state.data_loader,\n                        selected_drivers,\n                        telemetry_type.lower()\n                    )\n                    if fig:\n                        st.plotly_chart(fig, use_container_width=True)\n                    else:\n                        st.error(\"Unable to generate telemetry plot\")\n                except Exception as e:\n                    st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n        \n        with tab2:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">🗺️ Track Dominance Map</div>', unsafe_allow_html=True)\n            \n            with st.spinner(\"Creating track dominance map...\"):\n                try:\n                    fig = create_track_dominance_map(\n                        st.session_state.data_loader,\n                        selected_drivers\n                    )\n                    if fig:\n                        st.plotly_chart(fig, use_container_width=True)\n                    else:\n                        st.error(\"Unable to generate track map\")\n                except Exception as e:\n                    st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n        \n        with tab3:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">⏱️ Lap Time Comparison</div>', unsafe_allow_html=True)\n            \n            try:\n                session = st.session_state.data_loader.session\n                laps_data = []\n                \n                for driver in selected_drivers:\n                    driver_laps = session.laps.pick_drivers([driver]).pick_quicklaps()\n                    if not driver_laps.empty:\n                        best_lap = driver_laps.pick_fastest()\n                        lap_time = best_lap['LapTime'].total_seconds()\n                        laps_data.append({\n                            'Driver': driver,\n                            'Best Lap Time': format_lap_time(lap_time),\n                            'Lap Number': best_lap['LapNumber'],\n                            'Compound': best_lap['Compound']\n                        })\n                \n                if laps_data:\n                    df = pd.DataFrame(laps_data)\n                    st.dataframe(df, use_container_width=True, hide_index=True)\n                else:\n                    st.info(\"No lap data available\")\n                    \n            except Exception as e:\n                st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n        \n        with tab4:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">🔧 Tire Strategy Analysis</div>', unsafe_allow_html=True)\n            \n            with st.spinner(\"Analyzing tire strategy...\"):\n                try:\n                    fig = create_tire_strategy_plot(\n                        st.session_state.data_loader,\n                        selected_drivers\n                    )\n                    if fig:\n                        st.plotly_chart(fig, use_container_width=True)\n                    else:\n                        st.error(\"Unable to generate tire strategy plot\")\n                except Exception as e:\n                    st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n        \n        with tab5:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">📊 Race Progression</div>', unsafe_allow_html=True)\n            \n            with st.spinner(\"Creating race progression chart...\"):\n                try:\n                    fig = create_race_progression_plot(\n                        st.session_state.data_loader,\n                        selected_drivers\n                    )\n                    if fig:\n                        st.plotly_chart(fig, use_container_width=True)\n                    else:\n                        st.error(\"Unable to generate race progression plot\")\n                except Exception as e:\n                    st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n        \n        with tab6:\n            st.markdown('<div class=\"card\">', unsafe_allow_html=True)\n            st.markdown('<div class=\"card-header\">🧠 Advanced Analytics</div>', unsafe_allow_html=True)\n            \n            try:\n                analytics = AdvancedF1Analytics(st.session_state.data_loader.session)\n                results = analytics.analyze_driver_performance(selected_drivers)\n                \n                if not results.empty:\n                    # Display key metrics\n                    st.markdown(\"**Performance Metrics:**\")\n                    \n                    # Create metrics grid\n                    for _, row in results.iterrows():\n                        with st.container():\n                            st.markdown(f\"\"\"\n                            <div class=\"metric-grid\">\n                                <div class=\"metric-card\">\n                                    <div class=\"metric-value\">{row['Driver']}</div>\n                                    <div class=\"metric-label\">Driver</div>\n                                </div>\n                                <div class=\"metric-card\">\n                                    <div class=\"metric-value\">{row['Consistency_Score']:.2f}</div>\n                                    <div class=\"metric-label\">Consistency</div>\n                                </div>\n                                <div class=\"metric-card\">\n                                    <div class=\"metric-value\">{row['Sector_Dominance']:.1f}%</div>\n                                    <div class=\"metric-label\">Sector Dominance</div>\n                                </div>\n                                <div class=\"metric-card\">\n                                    <div class=\"metric-value\">{row['Average_Lap_Time']}</div>\n                                    <div class=\"metric-label\">Avg Lap Time</div>\n                                </div>\n                            </div>\n                            \"\"\", unsafe_allow_html=True)\n                    \n                    # Full data table\n                    st.markdown(\"**Detailed Analytics:**\")\n                    st.dataframe(results, use_container_width=True, hide_index=True)\n                else:\n                    st.info(\"No analytics data available\")\n                    \n            except Exception as e:\n                st.error(f\"Error: {str(e)}\")\n            \n            st.markdown('</div>', unsafe_allow_html=True)\n    \n    elif not selected_drivers and hasattr(st.session_state.data_loader, 'session'):\n        st.info(\"👆 Select drivers to view analysis tabs\")\n    else:\n        st.info(\"⬆️ Load session data and select drivers to begin analysis\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":21274},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTrack.lytix - F1 Data Analysis Platform\nMain entry point for command line execution\n\nUsage:\n    python main.py\n\nThis will start the Streamlit application on http://localhost:5000\n\"\"\"\n\nimport subprocess\nimport sys\nimport os\nfrom pathlib import Path\n\ndef check_dependencies():\n    \"\"\"Check if required packages are installed\"\"\"\n    required_packages = [\n        'streamlit',\n        'fastf1',\n        'plotly',\n        'pandas',\n        'numpy',\n        'scipy'\n    ]\n    \n    missing_packages = []\n    \n    for package in required_packages:\n        try:\n            __import__(package)\n        except ImportError:\n            missing_packages.append(package)\n    \n    if missing_packages:\n        print(\"❌ Missing required packages:\")\n        for package in missing_packages:\n            print(f\"   - {package}\")\n        print(\"\\n💡 Install missing packages with:\")\n        print(f\"   pip install {' '.join(missing_packages)}\")\n        return False\n    \n    return True\n\ndef setup_streamlit_config():\n    \"\"\"Create Streamlit configuration directory and file\"\"\"\n    config_dir = Path('.streamlit')\n    config_dir.mkdir(exist_ok=True)\n    \n    config_file = config_dir / 'config.toml'\n    \n    config_content = \"\"\"[server]\nheadless = true\naddress = \"0.0.0.0\"\nport = 5000\nrunOnSave = false\nfileWatcherType = \"none\"\n\n[theme]\nbase = \"dark\"\nprimaryColor = \"#00FFE6\"\nbackgroundColor = \"#0E0E0E\"\nsecondaryBackgroundColor = \"#1A1A1A\"\ntextColor = \"#FFFFFF\"\n\n[browser]\ngatherUsageStats = false\n\"\"\"\n    \n    with open(config_file, 'w') as f:\n        f.write(config_content)\n    \n    print(\"✅ Streamlit configuration created\")\n\ndef get_local_ip():\n    \"\"\"Get local IP address for network access\"\"\"\n    try:\n        import socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        s.connect((\"8.8.8.8\", 80))\n        local_ip = s.getsockname()[0]\n        s.close()\n        return local_ip\n    except:\n        return \"127.0.0.1\"\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    print(\"🏎️  Track.lytix - F1 Data Analysis Platform\")\n    print(\"=\" * 60)\n    print(\"   Professional F1 Analytics & Telemetry Platform\")\n    print(\"   ✓ Enhanced Brake Configurations Analysis\")\n    print(\"   ✓ Composite Performance Index Calculations\")\n    print(\"   ✓ Advanced Telemetry & Race Strategy Analytics\")\n    print(\"=\" * 60)\n    \n    # Check if we're in the right directory\n    if not os.path.exists('app.py'):\n        print(\"❌ Error: app.py not found in current directory\")\n        print(\"   Please run this script from the Track.lytix project directory\")\n        sys.exit(1)\n    \n    # Check dependencies\n    print(\"🔍 Checking dependencies...\")\n    if not check_dependencies():\n        sys.exit(1)\n    \n    print(\"✅ All dependencies found\")\n    \n    # Setup Streamlit configuration\n    setup_streamlit_config()\n    \n    # Get network information\n    local_ip = get_local_ip()\n    \n    # Start Streamlit application\n    print(\"\\n🚀 Starting Track.lytix F1 Platform...\")\n    print(\"=\" * 60)\n    print(\"📱 ACCESS URLS:\")\n    print(f\"   🖥️  Local:    http://localhost:5000\")\n    print(f\"   🌐 Network:  http://{local_ip}:5000\")\n    print(f\"   ☁️  Online:   http://0.0.0.0:5000 (if deployed)\")\n    print(\"=\" * 60)\n    print(\"📊 AVAILABLE ANALYSES:\")\n    print(\"   • Telemetry Comparison & Speed Analysis\")\n    print(\"   • Brake Configurations & Efficiency\")\n    print(\"   • Composite Performance Index\")\n    print(\"   • Tire Strategy & Degradation\")\n    print(\"   • Track Dominance Mapping\")\n    print(\"   • Advanced Driver Analytics\")\n    print(\"=\" * 60)\n    print(\"⚠️  Press Ctrl+C to stop the server\")\n    print(\"\")\n    \n    try:\n        # Run Streamlit with proper configuration for both local and online testing\n        cmd = [\n            sys.executable, \"-m\", \"streamlit\", \"run\", \"app.py\",\n            \"--server.port\", \"5000\",\n            \"--server.address\", \"0.0.0.0\",\n            \"--server.headless\", \"true\",\n            \"--server.runOnSave\", \"true\",\n            \"--server.allowRunOnSave\", \"true\"\n        ]\n        \n        subprocess.run(cmd)\n        \n    except KeyboardInterrupt:\n        print(\"\\n\\n👋 Track.lytix F1 Platform stopped gracefully\")\n        print(\"   Thank you for using Track.lytix!\")\n    except Exception as e:\n        print(f\"\\n❌ Error starting Track.lytix: {e}\")\n        print(\"   Please check your Python installation and dependencies\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()","size_bytes":4495},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"fastapi>=0.116.1\",\n    \"fastf1>=3.6.0\",\n    \"matplotlib>=3.10.3\",\n    \"numpy>=2.3.2\",\n    \"pandas>=2.3.1\",\n    \"plotly>=6.2.0\",\n    \"pydantic>=2.11.7\",\n    \"scikit-learn>=1.7.1\",\n    \"scipy>=1.16.0\",\n    \"streamlit>=1.47.0\",\n    \"uvicorn>=0.35.0\",\n]\n","size_bytes":397},"replit.md":{"content":"# Track.lytix - F1 Data Analysis Platform\n\n## Overview\nTrack.lytix is a comprehensive Formula 1 data analysis platform that provides advanced race data visualization and analytics. It leverages the FastF1 library to access official F1 timing data and creates interactive visualizations. The platform offers capabilities such as telemetry analysis, race progression tracking, tire strategy visualization, track dominance mapping, advanced driver performance analytics, weather impact analysis, and sophisticated race strategy evaluation. The project aims to offer a professional, mobile-responsive web application experience with F1-themed aesthetics.\n\n## User Preferences\nPreferred communication style: Simple, everyday language.\nDesign preferences: Professional, minimal, attractive design with enhanced F1-themed styling.\nData formatting: Lap times in M:SS.mmm format (e.g., 1:34.342).\nAnalysis requirements: Comprehensive sector analysis, detailed driver comparisons, enhanced track dominance visualization.\n\n## System Architecture\n\n### UI/UX Decisions\nThe platform features a modern, mobile-responsive F1 web application with dynamic animations and F1-themed styling. This includes professional F1 gradient backgrounds, racing animations, championship-style effects, and the Orbitron racing font. The layout is centered, often using a three-column structure, with an app-like tab system. Interactive elements like data tables and metric cards are designed with racing themes and team colors, incorporating glass morphism, glow effects, and high-contrast F1 styling for enhanced visibility.\n\n### Technical Implementations\nThe system has evolved to a modern architecture but maintains a legacy Streamlit interface.\n\n**Current (Next.js/TypeScript) Architecture:**\n- **Frontend Framework**: Next.js 14 with React 18 and TypeScript.\n- **Build Tool**: Turbopack.\n- **Styling**: Tailwind CSS with a high-contrast F1-themed design system and professional glass morphism.\n- **Animations**: Framer Motion for smooth transitions.\n- **UI Components**: Headless UI, Heroicons, and custom F1-themed components.\n- **Data Visualization**: Recharts for interactive charts.\n- **Layout**: Responsive design with dynamic tab system and mobile-first approach.\n- **API Integration**: Axios for seamless communication with FastAPI.\n\n**Legacy (Streamlit) Architecture (Preserved):**\n- **Framework**: Streamlit web application with custom CSS styling.\n- **Visualization Library**: Plotly for interactive charts and graphs.\n- **UI Components**: Custom F1-themed styling with team colors and gradients.\n- **Layout**: Wide layout with an expandable sidebar.\n\n**Backend Architecture:**\n- **API Server**: FastAPI with automatic OpenAPI documentation and CORS support.\n- **Data Processing**: Python-based backend using the FastF1 library for F1 data access.\n- **Data Management**: Modular utility classes for brake analysis, composite performance, and advanced analytics.\n- **Caching Strategy**: Session-level caching with FastF1's built-in system.\n- **Session Management**: Global session state with intelligent driver-team mapping.\n- **RESTful Endpoints**: Comprehensive API for telemetry, brake analysis, composite performance, and tire analytics.\n\n### Feature Specifications\n- **Telemetry Analysis**: Multi-parameter telemetry analysis (speed, throttle, brake, RPM, gear) with 6-channel visualization.\n- **Race Progression Tracking**: Visualization of position changes and annotations.\n- **Tire Strategy Visualization**: Detailed tire strategy statistics, compound performance analysis, stint length annotations, and gradient effects.\n- **Track Dominance Mapping**: Generation of track dominance maps showing fastest sectors, including track coordinate interpolation and mini-sector analysis.\n- **Advanced Driver Performance Analytics**: Comprehensive driver analysis, consistency metrics, and sector dominance metrics.\n- **Weather Impact Analysis**: Correlation of weather data with lap time performance.\n- **Race Strategy Evaluation**: Advanced pit stop strategy and fuel effect analysis with pace evolution tracking.\n- **Brake Analysis**: Comprehensive brake efficiency analysis with force and duration metrics.\n- **Composite Performance Index**: Advanced performance calculation combining speed, acceleration, and efficiency.\n- **Dynamic Driver Management**: Real-time driver information management and intelligent driver-team mapping from session data.\n\n### System Design Choices\n- **Data Flow**: User selects session -> DataLoader fetches data via FastF1 -> Data processed and cleaned -> Plotly charts generated -> Streamlit renders visualizations -> Data cached locally.\n- **Data Storage**: Local file system caching via FastF1, in-memory storage for loaded F1 session data, JSON for configuration, and temporary storage in the system temp directory for cache.\n- **Modularity**: Prioritizes modularity and maintainability with clearly defined modules for data loading, visualization, track dominance, constants, and driver management.\n\n## External Dependencies\n\n- **FastF1**: Primary library for accessing official F1 telemetry and timing data.\n- **Streamlit**: Web application framework (for the preserved legacy interface).\n- **Plotly**: Interactive visualization library.\n- **Pandas/NumPy**: For data manipulation and numerical computing.\n- **SciPy**: For scientific computing and data interpolation.\n- **Next.js**: Frontend framework for the modern web application.\n- **React**: JavaScript library for building user interfaces.\n- **TypeScript**: Superset of JavaScript for type safety.\n- **Tailwind CSS**: Utility-first CSS framework for styling.\n- **Framer Motion**: Animation library for React.\n- **Recharts**: Charting library for React (for the modern frontend).\n- **FastAPI**: Backend API server framework.\n- **Axios**: HTTP client for browser and Node.js (for API integration).","size_bytes":5871},"web_app_enhancements.py":{"content":"\"\"\"\nModern Web App Enhancements for Track.lytix F1 Platform\nAdd stunning mobile-responsive styling and app-like experience\n\"\"\"\n\n# Enhanced Hero Section with Racing Animations\nhero_section = \"\"\"\n<div style=\"\n    background: linear-gradient(135deg, #FF0033 0%, #FF8C00 30%, #FFD700 60%, #00FFE6 100%);\n    padding: 4rem 2rem;\n    margin: -2rem -2rem 3rem -2rem;\n    text-align: center;\n    position: relative;\n    overflow: hidden;\n    border-radius: 0 0 40px 40px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);\n\">\n    <div style=\"position: absolute; top: 0; left: -100%; width: 100%; height: 100%; \n                background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\n                animation: shine 3s infinite ease-in-out;\"></div>\n    \n    <h1 style=\"\n        font-family: 'Orbitron', monospace;\n        font-size: clamp(3rem, 8vw, 5rem);\n        font-weight: 900;\n        margin: 0;\n        color: white;\n        text-shadow: 0 5px 15px rgba(0,0,0,0.8);\n        animation: pulse 2s infinite ease-in-out;\n    \">🏎️ Track.lytix</h1>\n    \n    <p style=\"\n        font-size: clamp(1.2rem, 3vw, 1.8rem);\n        color: rgba(255,255,255,0.95);\n        font-weight: 600;\n        margin: 1rem 0;\n        font-family: 'Inter', sans-serif;\n    \">Professional F1 Data Analysis Platform</p>\n    \n    <p style=\"\n        font-size: clamp(1rem, 2.5vw, 1.3rem);\n        color: rgba(255,255,255,0.85);\n        margin: 1.5rem 0;\n        font-weight: 500;\n    \">🚀 Advanced Telemetry • 📊 Race Strategy • ⚡ Performance Analytics</p>\n    \n    <div style=\"\n        display: flex;\n        gap: 1rem;\n        justify-content: center;\n        flex-wrap: wrap;\n        margin-top: 2rem;\n    \">\n        <span style=\"\n            background: rgba(255,0,51,0.3);\n            padding: 0.8rem 1.5rem;\n            border-radius: 30px;\n            color: white;\n            font-weight: 700;\n            border: 2px solid rgba(255,0,51,0.6);\n            backdrop-filter: blur(10px);\n            font-size: 0.9rem;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n        \">Live F1 Data</span>\n        <span style=\"\n            background: rgba(0,255,230,0.3);\n            padding: 0.8rem 1.5rem;\n            border-radius: 30px;\n            color: white;\n            font-weight: 700;\n            border: 2px solid rgba(0,255,230,0.6);\n            backdrop-filter: blur(10px);\n            font-size: 0.9rem;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n        \">Real-time Analytics</span>\n        <span style=\"\n            background: rgba(255,215,0,0.3);\n            padding: 0.8rem 1.5rem;\n            border-radius: 30px;\n            color: white;\n            font-weight: 700;\n            border: 2px solid rgba(255,215,0,0.6);\n            backdrop-filter: blur(10px);\n            font-size: 0.9rem;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n        \">Professional Insights</span>\n    </div>\n</div>\n\n<style>\n@keyframes shine {\n    0% { left: -100%; }\n    100% { left: 100%; }\n}\n\n@keyframes pulse {\n    0%, 100% { transform: scale(1); }\n    50% { transform: scale(1.02); }\n}\n</style>\n\"\"\"\n\n# Enhanced Sidebar Styling\nsidebar_enhancement = \"\"\"\n<style>\n/* Revolutionary Sidebar */\n.css-1d391kg, .css-1aumxhk {\n    background: linear-gradient(180deg, rgba(5,5,5,0.98) 0%, rgba(15,15,15,0.95) 100%) !important;\n    backdrop-filter: blur(25px) !important;\n    border-right: 2px solid rgba(0,255,230,0.3) !important;\n    box-shadow: 5px 0 20px rgba(0,255,230,0.2) !important;\n}\n\n/* Enhanced Selectboxes */\n.stSelectbox > div > div {\n    background: linear-gradient(145deg, rgba(20,20,20,0.9), rgba(35,35,35,0.8)) !important;\n    border: 2px solid rgba(0,255,230,0.4) !important;\n    border-radius: 15px !important;\n    color: white !important;\n    backdrop-filter: blur(15px) !important;\n    transition: all 0.3s ease !important;\n}\n\n.stSelectbox > div > div:hover {\n    border-color: rgba(0,255,230,0.8) !important;\n    transform: translateY(-2px) !important;\n    box-shadow: 0 5px 15px rgba(0,255,230,0.3) !important;\n}\n\n/* Enhanced Multiselect */\n.stMultiSelect > div > div {\n    background: linear-gradient(145deg, rgba(20,20,20,0.9), rgba(35,35,35,0.8)) !important;\n    border: 2px solid rgba(0,255,230,0.4) !important;\n    border-radius: 15px !important;\n    backdrop-filter: blur(15px) !important;\n}\n\n/* Enhanced Slider */\n.stSlider > div > div > div {\n    background: rgba(0,255,230,0.3) !important;\n}\n\n.stSlider > div > div > div > div {\n    background: linear-gradient(45deg, #FF0033, #00FFE6) !important;\n    box-shadow: 0 0 10px rgba(0,255,230,0.5) !important;\n}\n</style>\n\"\"\"\n\n# Mobile-First Responsive Design\nmobile_responsive = \"\"\"\n<style>\n/* Mobile-First Responsive Design */\n@media (max-width: 1200px) {\n    .metric-card {\n        padding: 2rem !important;\n        margin: 1rem 0 !important;\n    }\n}\n\n@media (max-width: 768px) {\n    .main-header h1 {\n        font-size: 3rem !important;\n    }\n    \n    .metric-card {\n        padding: 1.5rem !important;\n        margin: 1rem 0 !important;\n        border-radius: 15px !important;\n    }\n    \n    .stTabs [data-baseweb=\"tab\"] {\n        height: 50px !important;\n        padding: 0 0.8rem !important;\n        font-size: 0.8rem !important;\n    }\n    \n    .stDataFrame thead tr th {\n        padding: 1rem 0.5rem !important;\n        font-size: 0.8rem !important;\n    }\n    \n    .stDataFrame tbody tr td {\n        padding: 0.8rem 0.5rem !important;\n        font-size: 0.8rem !important;\n    }\n}\n\n@media (max-width: 480px) {\n    .main-header {\n        padding: 2rem 1rem !important;\n        margin: -1rem -1rem 2rem -1rem !important;\n    }\n    \n    .metric-card {\n        padding: 1rem !important;\n        border-radius: 12px !important;\n    }\n    \n    .stTabs [data-baseweb=\"tab-list\"] {\n        padding: 0.5rem !important;\n        gap: 4px !important;\n    }\n    \n    .stTabs [data-baseweb=\"tab\"] {\n        height: 45px !important;\n        padding: 0 0.6rem !important;\n        font-size: 0.75rem !important;\n    }\n}\n</style>\n\"\"\"\n\n# Performance Optimizations\nperformance_css = \"\"\"\n<style>\n/* Performance Optimizations */\n* {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    text-rendering: optimizeLegibility;\n}\n\n.main .block-container {\n    will-change: transform;\n    transform: translateZ(0);\n}\n\n.metric-card, .stTabs [data-baseweb=\"tab\"], .stButton > button {\n    will-change: transform, box-shadow;\n    transform: translateZ(0);\n}\n\n/* Preload animations */\n@keyframes fadeInUp {\n    from { opacity: 0; transform: translateY(30px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n.metric-card {\n    animation: fadeInUp 0.6s ease-out forwards;\n}\n\n.metric-card:nth-child(1) { animation-delay: 0.1s; }\n.metric-card:nth-child(2) { animation-delay: 0.2s; }\n.metric-card:nth-child(3) { animation-delay: 0.3s; }\n</style>\n\"\"\"","size_bytes":6913},"attached_assets/Brake Configurations_1753519666071.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\n\r\n# Define team colors\r\nteam_colors = {\r\n    'Mercedes': '#00D2BE',\r\n    'Red Bull Racing': '#1E41FF',\r\n    'Ferrari': '#DC0000',\r\n    'McLaren': '#FF8700',\r\n    'Alpine': '#0090FF',\r\n    'AlphaTauri': '#4E7C9B',\r\n    'Aston Martin': '#006F62',\r\n    'Williams': '#005AFF',\r\n    'Alfa Romeo': '#900000',\r\n    'RB': '#6692FF',\r\n    'Kick Sauber': '#52E252',\r\n    'Haas F1 Team': '#FFFFFF'\r\n}\r\n\r\n# Load the session data\r\nyear = 2024\r\ngrand_prix = 'Canada'\r\nsession_type = 'R'  # Race session\r\n\r\nsession = ff1.get_session(year, grand_prix, session_type)\r\nsession.load()\r\n\r\n# Get all drivers\r\ndrivers = session.drivers\r\n\r\n# Create a DataFrame to store results\r\nresults = []\r\n\r\nfor driver in drivers:\r\n    driver_laps = session.laps.pick_driver(driver)\r\n    fastest_lap = driver_laps.pick_fastest()\r\n    \r\n    if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n        print(f\"Skipping driver {driver} due to invalid DriverNumber\")\r\n        continue\r\n    \r\n    try:\r\n        telemetry = fastest_lap.get_car_data().add_distance()\r\n    except KeyError as e:\r\n        print(f\"Skipping driver {driver} due to KeyError: {e}\")\r\n        continue\r\n    \r\n    # Brake and speed data\r\n    brake_data = telemetry['Brake']  # 1 when braking, 0 when not\r\n    speed_data = telemetry['Speed']\r\n    \r\n    # Calculate time spent braking (duration of braking)\r\n    braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Total lap time in seconds\r\n    lap_time_seconds = fastest_lap['LapTime'].total_seconds()\r\n    \r\n    # Brake efficiency: percentage of time spent braking\r\n    brake_efficiency = (braking_duration / lap_time_seconds) * 100\r\n    \r\n    driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n    team_name = session.get_driver(driver)['TeamName']\r\n    \r\n    results.append({\r\n        'Driver': driver_name,\r\n        'Brake Efficiency (%)': brake_efficiency,\r\n        'Lap Time (s)': lap_time_seconds,\r\n        'Team': team_name\r\n    })\r\n\r\n# Convert results to DataFrame\r\ndf_results = pd.DataFrame(results)\r\n\r\n# Sort the DataFrame by Brake Efficiency\r\ndf_results = df_results.sort_values(by='Brake Efficiency (%)', ascending=False)\r\n\r\n# Plot the results\r\nplt.figure(figsize=(16, 10), facecolor='black')\r\nax = plt.gca()\r\nax.set_facecolor('black')\r\n\r\nbars = plt.bar(df_results['Driver'], df_results['Brake Efficiency (%)'], color=[team_colors[team] for team in df_results['Team']])\r\nplt.xlabel('Driver', color='white')\r\nplt.ylabel('Brake Efficiency (%)', color='white')\r\nplt.title(f'{grand_prix} {year} {session_type} Brake Efficiency Comparison', color='white', fontsize=18)\r\nplt.xticks(rotation=45, color='white')\r\nplt.yticks(color='white')\r\nplt.grid(color='gray', linestyle='--', linewidth=0.5, axis='y', alpha=0.7)\r\n\r\n# Add the brake efficiency value on top of each bar\r\nfor bar in bars:\r\n    yval = bar.get_height()\r\n    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:.2f}', ha='center', va='bottom', color='white')\r\n\r\n# Add average line\r\nmean_efficiency = df_results['Brake Efficiency (%)'].mean()\r\nplt.axhline(mean_efficiency, color='red', linewidth=1.5, linestyle='--')\r\nplt.text(len(df_results) - 1, mean_efficiency, f'Mean: {mean_efficiency:.2f}', color='red', ha='center', va='bottom')\r\n\r\n# Add team names below driver names\r\nfor i, (driver, team) in enumerate(zip(df_results['Driver'], df_results['Team'])):\r\n    plt.text(i, -2, team, ha='center', va='top', color='white', fontsize=10, rotation=45)\r\n\r\n# Add description text below the plot\r\nplt.figtext(0.5, -0.1, f\"Data obtained from fastest lap telemetry in the {year} {grand_prix} GP race session using FAST F1 library\", wrap=True, horizontalalignment='center', fontsize=12, color='white')\r\nplt.figtext(0.5, -0.15, \"The plot shows the percentage of time each driver spent braking during their fastest lap\", wrap=True, horizontalalignment='center', fontsize=10, color='white')\r\n\r\n# Update and enlarge watermark\r\nplt.figtext(0.5, 0.5, 'F1 DATA IQ', fontsize=70, color='gray', ha='center', va='center', alpha=0.5, rotation=45)\r\n\r\n# Display the plot\r\nplt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit description text\r\nplt.show()\r\n","size_bytes":4254},"attached_assets/Brake Configurations_1753526997559.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\n\r\n# Define team colors\r\nteam_colors = {\r\n    'Mercedes': '#00D2BE',\r\n    'Red Bull Racing': '#1E41FF',\r\n    'Ferrari': '#DC0000',\r\n    'McLaren': '#FF8700',\r\n    'Alpine': '#0090FF',\r\n    'AlphaTauri': '#4E7C9B',\r\n    'Aston Martin': '#006F62',\r\n    'Williams': '#005AFF',\r\n    'Alfa Romeo': '#900000',\r\n    'RB': '#6692FF',\r\n    'Kick Sauber': '#52E252',\r\n    'Haas F1 Team': '#FFFFFF'\r\n}\r\n\r\n# Load the session data\r\nyear = 2024\r\ngrand_prix = 'Canada'\r\nsession_type = 'R'  # Race session\r\n\r\nsession = ff1.get_session(year, grand_prix, session_type)\r\nsession.load()\r\n\r\n# Get all drivers\r\ndrivers = session.drivers\r\n\r\n# Create a DataFrame to store results\r\nresults = []\r\n\r\nfor driver in drivers:\r\n    driver_laps = session.laps.pick_driver(driver)\r\n    fastest_lap = driver_laps.pick_fastest()\r\n    \r\n    if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n        print(f\"Skipping driver {driver} due to invalid DriverNumber\")\r\n        continue\r\n    \r\n    try:\r\n        telemetry = fastest_lap.get_car_data().add_distance()\r\n    except KeyError as e:\r\n        print(f\"Skipping driver {driver} due to KeyError: {e}\")\r\n        continue\r\n    \r\n    # Brake and speed data\r\n    brake_data = telemetry['Brake']  # 1 when braking, 0 when not\r\n    speed_data = telemetry['Speed']\r\n    \r\n    # Calculate time spent braking (duration of braking)\r\n    braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Total lap time in seconds\r\n    lap_time_seconds = fastest_lap['LapTime'].total_seconds()\r\n    \r\n    # Brake efficiency: percentage of time spent braking\r\n    brake_efficiency = (braking_duration / lap_time_seconds) * 100\r\n    \r\n    driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n    team_name = session.get_driver(driver)['TeamName']\r\n    \r\n    results.append({\r\n        'Driver': driver_name,\r\n        'Brake Efficiency (%)': brake_efficiency,\r\n        'Lap Time (s)': lap_time_seconds,\r\n        'Team': team_name\r\n    })\r\n\r\n# Convert results to DataFrame\r\ndf_results = pd.DataFrame(results)\r\n\r\n# Sort the DataFrame by Brake Efficiency\r\ndf_results = df_results.sort_values(by='Brake Efficiency (%)', ascending=False)\r\n\r\n# Plot the results\r\nplt.figure(figsize=(16, 10), facecolor='black')\r\nax = plt.gca()\r\nax.set_facecolor('black')\r\n\r\nbars = plt.bar(df_results['Driver'], df_results['Brake Efficiency (%)'], color=[team_colors[team] for team in df_results['Team']])\r\nplt.xlabel('Driver', color='white')\r\nplt.ylabel('Brake Efficiency (%)', color='white')\r\nplt.title(f'{grand_prix} {year} {session_type} Brake Efficiency Comparison', color='white', fontsize=18)\r\nplt.xticks(rotation=45, color='white')\r\nplt.yticks(color='white')\r\nplt.grid(color='gray', linestyle='--', linewidth=0.5, axis='y', alpha=0.7)\r\n\r\n# Add the brake efficiency value on top of each bar\r\nfor bar in bars:\r\n    yval = bar.get_height()\r\n    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:.2f}', ha='center', va='bottom', color='white')\r\n\r\n# Add average line\r\nmean_efficiency = df_results['Brake Efficiency (%)'].mean()\r\nplt.axhline(mean_efficiency, color='red', linewidth=1.5, linestyle='--')\r\nplt.text(len(df_results) - 1, mean_efficiency, f'Mean: {mean_efficiency:.2f}', color='red', ha='center', va='bottom')\r\n\r\n# Add team names below driver names\r\nfor i, (driver, team) in enumerate(zip(df_results['Driver'], df_results['Team'])):\r\n    plt.text(i, -2, team, ha='center', va='top', color='white', fontsize=10, rotation=45)\r\n\r\n# Add description text below the plot\r\nplt.figtext(0.5, -0.1, f\"Data obtained from fastest lap telemetry in the {year} {grand_prix} GP race session using FAST F1 library\", wrap=True, horizontalalignment='center', fontsize=12, color='white')\r\nplt.figtext(0.5, -0.15, \"The plot shows the percentage of time each driver spent braking during their fastest lap\", wrap=True, horizontalalignment='center', fontsize=10, color='white')\r\n\r\n# Update and enlarge watermark\r\nplt.figtext(0.5, 0.5, 'F1 DATA IQ', fontsize=70, color='gray', ha='center', va='center', alpha=0.5, rotation=45)\r\n\r\n# Display the plot\r\nplt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit description text\r\nplt.show()\r\n","size_bytes":4254},"attached_assets/Composite Performance Index (3)_1753519670608.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\n\r\n# Define team colors\r\nteam_colors = {\r\n    'Mercedes': '#00D2BE',\r\n    'Red Bull Racing': '#1E41FF',\r\n    'Ferrari': '#DC0000',\r\n    'McLaren': '#FF8700',\r\n    'Alpine': '#0090FF',\r\n    'AlphaTauri': '#4E7C9B',\r\n    'Aston Martin': '#006F62',\r\n    'Williams': '#005AFF',\r\n    'Alfa Romeo': '#900000',\r\n    'RB': '#6692FF',\r\n    'Kick Sauber': '#52E252',\r\n    'Haas F1 Team': '#FFFFFF'\r\n}\r\n\r\n# Load the session data\r\nyear = 2024\r\ngrand_prix = 'Canada'\r\nsession_type = 'R'  # Race session\r\n\r\nsession = ff1.get_session(year, grand_prix, session_type)\r\nsession.load()\r\n\r\n# Get all drivers\r\ndrivers = session.drivers\r\n\r\n# Create a DataFrame to store results\r\nresults = []\r\n\r\nfor driver in drivers:\r\n    driver_laps = session.laps.pick_driver(driver)\r\n    fastest_lap = driver_laps.pick_fastest()\r\n    \r\n    if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n        print(f\"Skipping driver {driver} due to invalid DriverNumber\")\r\n        continue\r\n    \r\n    try:\r\n        telemetry = fastest_lap.get_car_data().add_distance()\r\n    except KeyError as e:\r\n        print(f\"Skipping driver {driver} due to KeyError: {e}\")\r\n        continue\r\n    \r\n    # Speed, acceleration and brake data\r\n    brake_data = telemetry['Brake']  # 1 when braking, 0 when not\r\n    speed_data = telemetry['Speed']\r\n    acceleration_data = speed_data.diff() / telemetry['Distance'].diff()  # Basic acceleration calculation\r\n    \r\n    # Calculate time spent braking (duration of braking)\r\n    braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Total lap time in seconds\r\n    lap_time_seconds = fastest_lap['LapTime'].total_seconds()\r\n    \r\n    # Brake efficiency: percentage of time spent braking\r\n    brake_efficiency = (braking_duration / lap_time_seconds) * 100\r\n    \r\n    # Speed factor\r\n    speed_factor = speed_data.mean()\r\n    \r\n    # Acceleration factor\r\n    acceleration_factor = acceleration_data[acceleration_data > 0].mean()  # Acceleration (positive changes in speed)\r\n    \r\n    # Handling time (time spent at speeds lower than a threshold, indicating cornering)\r\n    handling_threshold = speed_data.mean() * 0.7  # Assuming cornering happens at 70% of the average speed\r\n    handling_time = len(speed_data[speed_data < handling_threshold]) * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Composite Performance Index\r\n    composite_performance_index = (speed_factor * acceleration_factor) / (brake_efficiency + handling_time)\r\n    \r\n    driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n    team_name = session.get_driver(driver)['TeamName']\r\n    \r\n    results.append({\r\n        'Driver': driver_name,\r\n        'Composite Performance Index': composite_performance_index,\r\n        'Speed Factor': speed_factor,\r\n        'Acceleration Factor': acceleration_factor,\r\n        'Brake Efficiency (%)': brake_efficiency,\r\n        'Handling Time (s)': handling_time,\r\n        'Lap Time (s)': lap_time_seconds,\r\n        'Team': team_name\r\n    })\r\n\r\n# Convert results to DataFrame\r\ndf_results = pd.DataFrame(results)\r\n\r\n# Sort the DataFrame by Composite Performance Index\r\ndf_results = df_results.sort_values(by='Composite Performance Index', ascending=False)\r\n\r\n# Plot the results\r\nfig, ax = plt.subplots(figsize=(16, 10), facecolor='black')\r\nax.set_facecolor('black')\r\n\r\n# Bar chart for Composite Performance Index\r\nbars = plt.bar(df_results['Driver'], df_results['Composite Performance Index'], color=[team_colors[team] for team in df_results['Team']])\r\nplt.xlabel('Driver', color='white', fontsize=12)\r\nplt.ylabel('Composite Performance Index', color='white', fontsize=12)\r\n\r\n# Adjust title placement to be closer to the top\r\nplt.title(f'{grand_prix} {year} {session_type} - Composite Performance Index', color='white', fontsize=20, pad=20)\r\nplt.xticks(rotation=45, color='white', fontsize=10)\r\nplt.yticks(color='white', fontsize=10)\r\nplt.grid(color='gray', linestyle='--', linewidth=0.5, axis='y', alpha=0.7)\r\n\r\n# Add the composite performance index value on top of each bar\r\nfor bar in bars:\r\n    yval = bar.get_height()\r\n    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:.2f}', ha='center', va='bottom', color='white')\r\n\r\n# Add average line for composite performance index\r\nmean_performance = df_results['Composite Performance Index'].mean()\r\nplt.axhline(mean_performance, color='red', linewidth=1.5, linestyle='--')\r\nplt.text(len(df_results) - 1, mean_performance, f'Mean: {mean_performance:.2f}', color='red', ha='center', va='bottom')\r\n\r\n# Add team names below driver names\r\nfor i, (driver, team) in enumerate(zip(df_results['Driver'], df_results['Team'])):\r\n    plt.text(i, -2, team, ha='center', va='top', color='white', fontsize=10, rotation=45)\r\n\r\n# Display the calculation formula at the bottom of the plot\r\nplt.figtext(0.5, 0.85, \"Composite Performance Index = (Speed Factor * Acceleration Factor) / (Brake Efficiency + Handling Time)\", wrap=True, horizontalalignment='center', fontsize=12, color='white')\r\n\r\n# Update and enlarge watermark\r\nplt.figtext(0.5, 0.5, 'F1 DATA IQ', fontsize=70, color='gray', ha='center', va='center', alpha=0.3, rotation=45)\r\n\r\n# Display the plot\r\nplt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit description text\r\nplt.show()\r\n","size_bytes":5355},"attached_assets/Composite Performance Index (3)_1753527001810.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\n\r\n# Define team colors\r\nteam_colors = {\r\n    'Mercedes': '#00D2BE',\r\n    'Red Bull Racing': '#1E41FF',\r\n    'Ferrari': '#DC0000',\r\n    'McLaren': '#FF8700',\r\n    'Alpine': '#0090FF',\r\n    'AlphaTauri': '#4E7C9B',\r\n    'Aston Martin': '#006F62',\r\n    'Williams': '#005AFF',\r\n    'Alfa Romeo': '#900000',\r\n    'RB': '#6692FF',\r\n    'Kick Sauber': '#52E252',\r\n    'Haas F1 Team': '#FFFFFF'\r\n}\r\n\r\n# Load the session data\r\nyear = 2024\r\ngrand_prix = 'Canada'\r\nsession_type = 'R'  # Race session\r\n\r\nsession = ff1.get_session(year, grand_prix, session_type)\r\nsession.load()\r\n\r\n# Get all drivers\r\ndrivers = session.drivers\r\n\r\n# Create a DataFrame to store results\r\nresults = []\r\n\r\nfor driver in drivers:\r\n    driver_laps = session.laps.pick_driver(driver)\r\n    fastest_lap = driver_laps.pick_fastest()\r\n    \r\n    if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n        print(f\"Skipping driver {driver} due to invalid DriverNumber\")\r\n        continue\r\n    \r\n    try:\r\n        telemetry = fastest_lap.get_car_data().add_distance()\r\n    except KeyError as e:\r\n        print(f\"Skipping driver {driver} due to KeyError: {e}\")\r\n        continue\r\n    \r\n    # Speed, acceleration and brake data\r\n    brake_data = telemetry['Brake']  # 1 when braking, 0 when not\r\n    speed_data = telemetry['Speed']\r\n    acceleration_data = speed_data.diff() / telemetry['Distance'].diff()  # Basic acceleration calculation\r\n    \r\n    # Calculate time spent braking (duration of braking)\r\n    braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Total lap time in seconds\r\n    lap_time_seconds = fastest_lap['LapTime'].total_seconds()\r\n    \r\n    # Brake efficiency: percentage of time spent braking\r\n    brake_efficiency = (braking_duration / lap_time_seconds) * 100\r\n    \r\n    # Speed factor\r\n    speed_factor = speed_data.mean()\r\n    \r\n    # Acceleration factor\r\n    acceleration_factor = acceleration_data[acceleration_data > 0].mean()  # Acceleration (positive changes in speed)\r\n    \r\n    # Handling time (time spent at speeds lower than a threshold, indicating cornering)\r\n    handling_threshold = speed_data.mean() * 0.7  # Assuming cornering happens at 70% of the average speed\r\n    handling_time = len(speed_data[speed_data < handling_threshold]) * (telemetry['Distance'].diff().mean() / speed_data.mean())\r\n    \r\n    # Composite Performance Index\r\n    composite_performance_index = (speed_factor * acceleration_factor) / (brake_efficiency + handling_time)\r\n    \r\n    driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n    team_name = session.get_driver(driver)['TeamName']\r\n    \r\n    results.append({\r\n        'Driver': driver_name,\r\n        'Composite Performance Index': composite_performance_index,\r\n        'Speed Factor': speed_factor,\r\n        'Acceleration Factor': acceleration_factor,\r\n        'Brake Efficiency (%)': brake_efficiency,\r\n        'Handling Time (s)': handling_time,\r\n        'Lap Time (s)': lap_time_seconds,\r\n        'Team': team_name\r\n    })\r\n\r\n# Convert results to DataFrame\r\ndf_results = pd.DataFrame(results)\r\n\r\n# Sort the DataFrame by Composite Performance Index\r\ndf_results = df_results.sort_values(by='Composite Performance Index', ascending=False)\r\n\r\n# Plot the results\r\nfig, ax = plt.subplots(figsize=(16, 10), facecolor='black')\r\nax.set_facecolor('black')\r\n\r\n# Bar chart for Composite Performance Index\r\nbars = plt.bar(df_results['Driver'], df_results['Composite Performance Index'], color=[team_colors[team] for team in df_results['Team']])\r\nplt.xlabel('Driver', color='white', fontsize=12)\r\nplt.ylabel('Composite Performance Index', color='white', fontsize=12)\r\n\r\n# Adjust title placement to be closer to the top\r\nplt.title(f'{grand_prix} {year} {session_type} - Composite Performance Index', color='white', fontsize=20, pad=20)\r\nplt.xticks(rotation=45, color='white', fontsize=10)\r\nplt.yticks(color='white', fontsize=10)\r\nplt.grid(color='gray', linestyle='--', linewidth=0.5, axis='y', alpha=0.7)\r\n\r\n# Add the composite performance index value on top of each bar\r\nfor bar in bars:\r\n    yval = bar.get_height()\r\n    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval:.2f}', ha='center', va='bottom', color='white')\r\n\r\n# Add average line for composite performance index\r\nmean_performance = df_results['Composite Performance Index'].mean()\r\nplt.axhline(mean_performance, color='red', linewidth=1.5, linestyle='--')\r\nplt.text(len(df_results) - 1, mean_performance, f'Mean: {mean_performance:.2f}', color='red', ha='center', va='bottom')\r\n\r\n# Add team names below driver names\r\nfor i, (driver, team) in enumerate(zip(df_results['Driver'], df_results['Team'])):\r\n    plt.text(i, -2, team, ha='center', va='top', color='white', fontsize=10, rotation=45)\r\n\r\n# Display the calculation formula at the bottom of the plot\r\nplt.figtext(0.5, 0.85, \"Composite Performance Index = (Speed Factor * Acceleration Factor) / (Brake Efficiency + Handling Time)\", wrap=True, horizontalalignment='center', fontsize=12, color='white')\r\n\r\n# Update and enlarge watermark\r\nplt.figtext(0.5, 0.5, 'F1 DATA IQ', fontsize=70, color='gray', ha='center', va='center', alpha=0.3, rotation=45)\r\n\r\n# Display the plot\r\nplt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit description text\r\nplt.show()\r\n","size_bytes":5355},"attached_assets/Tire Performance_1753515748253.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom matplotlib import cm\r\n\r\n# ==============================\r\n# تنظیمات و مقادیر پیش‌فرض\r\n# ==============================\r\n\r\nDEFAULT_YEAR = 2024\r\nDEFAULT_GRAND_PRIX = 'Canada'\r\nDEFAULT_SESSION_TYPE = 'R'  # Race\r\n\r\n# ==============================\r\n# توابع کمکی\r\n# ==============================\r\n\r\ndef load_session_data(year, grand_prix, session_type):\r\n    \"\"\"Load the F1 session data.\"\"\"\r\n    session = ff1.get_session(year, grand_prix, session_type)\r\n    session.load()\r\n    return session\r\n\r\ndef calculate_tire_performance(session):\r\n    \"\"\"Calculate tire performance metrics for all drivers.\"\"\"\r\n    drivers = session.drivers\r\n    results = []\r\n\r\n    for driver in drivers:\r\n        driver_laps = session.laps.pick_driver(driver)\r\n        fastest_lap = driver_laps.pick_fastest()\r\n        \r\n        if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n            continue\r\n        \r\n        try:\r\n            telemetry = fastest_lap.get_car_data().add_distance()\r\n        except KeyError:\r\n            continue\r\n\r\n        # Metrics calculation\r\n        speed_data = telemetry['Speed']\r\n        acceleration_data = speed_data.diff() / telemetry['Distance'].diff()\r\n        braking_data = telemetry['Brake']\r\n\r\n        # Tire Stress Index (Speed * Acceleration * Braking Factor)\r\n        braking_factor = braking_data.mean()  # 1: Constant braking, 0: No braking\r\n        tire_stress_index = (speed_data * acceleration_data.abs()).mean() * (1 + braking_factor)\r\n\r\n        # Tire Temperature (Simulated using Speed and Braking)\r\n        tire_temperature = speed_data.mean() * (1 + braking_factor) * 0.1  # Example scaling\r\n\r\n        # Tire Efficiency\r\n        tire_efficiency = speed_data.mean() / (1 + tire_stress_index)\r\n\r\n        # Tire Wear Index\r\n        tire_wear_index = tire_stress_index * 0.8 + braking_factor * 0.2\r\n\r\n        driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n        results.append({\r\n            'Driver': driver_name,\r\n            'Tire Stress Index': tire_stress_index,\r\n            'Tire Temperature': tire_temperature,\r\n            'Tire Efficiency': tire_efficiency,\r\n            'Tire Wear Index': tire_wear_index\r\n        })\r\n\r\n    return pd.DataFrame(results)\r\n\r\n# ==============================\r\n# توابع رسم نمودارها\r\n# ==============================\r\n\r\ndef plot_tire_performance(df_tires, grand_prix, year):\r\n    \"\"\"Plot tire performance analysis charts.\"\"\"\r\n    fig, axs = plt.subplots(2, 2, figsize=(18, 12), facecolor='black')\r\n    fig.suptitle(f'{grand_prix} {year} Tire Performance Analysis', color='white', fontsize=18, y=0.96)\r\n\r\n    # اضافه کردن واترمارک\r\n    fig.text(0.5, 0.5, 'F1 DATA IQ', fontsize=70, color='white', ha='center', va='center', alpha=0.55)\r\n\r\n    # تنظیم رنگ‌بندی محور‌ها\r\n    for ax in axs.flatten():\r\n        ax.set_facecolor('black')\r\n        ax.spines['bottom'].set_color('white')\r\n        ax.spines['top'].set_color('white')\r\n        ax.spines['left'].set_color('white')\r\n        ax.spines['right'].set_color('white')\r\n        ax.tick_params(colors='white')\r\n\r\n    # Tire Stress Index\r\n    axs[0, 0].bar(df_tires['Driver'], df_tires['Tire Stress Index'], color=cm.plasma(df_tires['Tire Stress Index'] / df_tires['Tire Stress Index'].max()))\r\n    axs[0, 0].set_title('Tire Stress Index', color='white', fontsize=12)\r\n    axs[0, 0].set_xlabel('', color='white', fontsize=10)\r\n    axs[0, 0].set_ylabel('Stress Index', color='white', fontsize=10)\r\n    axs[0, 0].axhline(df_tires['Tire Stress Index'].mean(), color='red', linestyle='--', label='Mean')\r\n    axs[0, 0].legend(facecolor='black', edgecolor='white', fontsize=8)\r\n\r\n    # Tire Temperature\r\n    axs[0, 1].bar(df_tires['Driver'], df_tires['Tire Temperature'], color=cm.inferno(df_tires['Tire Temperature'] / df_tires['Tire Temperature'].max()))\r\n    axs[0, 1].set_title('Tire Temperature', color='white', fontsize=12)\r\n    axs[0, 1].set_xlabel('', color='white', fontsize=10)\r\n    axs[0, 1].set_ylabel('Temperature (°C)', color='white', fontsize=10)\r\n    axs[0, 1].axhline(df_tires['Tire Temperature'].mean(), color='red', linestyle='--', label='Mean')\r\n    axs[0, 1].legend(facecolor='black', edgecolor='white', fontsize=8)\r\n\r\n    # Tire Efficiency\r\n    axs[1, 0].bar(df_tires['Driver'], df_tires['Tire Efficiency'], color=cm.Greens(df_tires['Tire Efficiency'] / df_tires['Tire Efficiency'].max()))\r\n    axs[1, 0].set_title('Tire Efficiency', color='white', fontsize=12)\r\n    axs[1, 0].set_xlabel('', color='white', fontsize=10)\r\n    axs[1, 0].set_ylabel('Efficiency', color='white', fontsize=10)\r\n    axs[1, 0].axhline(df_tires['Tire Efficiency'].mean(), color='red', linestyle='--', label='Mean')\r\n    axs[1, 0].legend(facecolor='black', edgecolor='white', fontsize=8)\r\n\r\n    # Tire Wear Index\r\n    axs[1, 1].bar(df_tires['Driver'], df_tires['Tire Wear Index'], color=cm.Purples(df_tires['Tire Wear Index'] / df_tires['Tire Wear Index'].max()))\r\n    axs[1, 1].set_title('Tire Wear Index', color='white', fontsize=12)\r\n    axs[1, 1].set_xlabel('', color='white', fontsize=10)\r\n    axs[1, 1].set_ylabel('Wear Index', color='white', fontsize=10)\r\n    axs[1, 1].axhline(df_tires['Tire Wear Index'].mean(), color='red', linestyle='--', label='Mean')\r\n    axs[1, 1].legend(facecolor='black', edgecolor='white', fontsize=8)\r\n\r\n    plt.tight_layout(rect=[0, 0, 1, 0.94])\r\n    plt.show()\r\n\r\n# ==============================\r\n# اجرای اصلی برنامه\r\n# ==============================\r\n\r\nsession = load_session_data(DEFAULT_YEAR, DEFAULT_GRAND_PRIX, DEFAULT_SESSION_TYPE)\r\ndf_tires = calculate_tire_performance(session)\r\n\r\n# نمایش نمودارها\r\nplot_tire_performance(df_tires, DEFAULT_GRAND_PRIX, DEFAULT_YEAR)\r\n","size_bytes":5863},"attached_assets/python f1_analysis_1753442487831.py":{"content":"import sys\r\nimport os\r\nimport json\r\nimport subprocess\r\nfrom PyQt6.QtWidgets import (\r\n    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,\r\n    QLabel, QPushButton, QFileDialog, QMessageBox, QScrollArea,\r\n    QFrame, QSizePolicy, QGridLayout\r\n)\r\nfrom PyQt6.QtGui import (\r\n    QFont, QPalette, QColor, QIcon, QPixmap, QPainter, QBrush, QLinearGradient, QCursor,\r\n    QDrag\r\n)\r\nfrom PyQt6.QtCore import Qt, QSize, QRect, QMimeData, QPoint\r\n\r\nCONFIG_FILE = \"f1_analysis_config.json\"\r\nSESSIONS = [\r\n    (\"Free Practice 1\", \"🏁\", \"FP1\"),\r\n    (\"Free Practice 2\", \"🏁\", \"FP2\"),\r\n    (\"Free Practice 3\", \"🏁\", \"FP3\"),\r\n    (\"Qualifying\", \"⏱️\", \"Q\"),\r\n    (\"Race\", \"🏆\", \"R\"),\r\n    (\"Sprint\", \"⭐\", \"S\"),\r\n    (\"Sprint Qualifying\", \"⚡\", \"SQ\"),\r\n]\r\n\r\nTOP_GRADIENT = \"qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #a18cd1, stop:1 #fbc2eb);\"\r\nCARD_BG = \"#23233c\"\r\nCARD_BG_HOVER = \"#343457\"\r\nACCENT_GRADIENT = \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #a18cd1, stop:1 #fbc2eb);\"\r\nSOFT_TEXT = \"#ecebff\"\r\nSUBTLE_TEXT = \"#b9b8cc\"\r\nACTIVE_TILE_BG = \"#a18cd1\"\r\nTILE_BG = \"#282846\"\r\nTILE_BG_HOVER = \"#3c3c5c\"\r\nTILE_BORDER = \"#baf0ff\"\r\nSESSION_GRADIENT = [\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #a18cd1, stop:1 #fbc2eb);\", # FP1\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #a1c4fd, stop:1 #c2e9fb);\", # FP2\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #b2fefa, stop:1 #f6d365);\", # FP3\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #fbc2eb, stop:1 #a6c1ee);\", # Q\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #f7797d, stop:1 #FBD786);\", # R\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #a1c4fd, stop:1 #c2e9fb);\", # S\r\n    \"qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #fbc2eb, stop:1 #a6c1ee);\"  # SQ\r\n]\r\n\r\nKALAMEH_FONT = \"Kalameh\"\r\nKALAMEH_FONT_PATH = \"Kalameh-Regular.ttf\"\r\nif os.path.exists(KALAMEH_FONT_PATH):\r\n    QFontDatabase = None\r\n    try:\r\n        from PyQt6.QtGui import QFontDatabase\r\n        QFontDatabase.addApplicationFont(KALAMEH_FONT_PATH)\r\n    except Exception:\r\n        pass\r\n\r\ndef load_config():\r\n    if os.path.exists(CONFIG_FILE):\r\n        try:\r\n            with open(CONFIG_FILE, \"r\") as f:\r\n                return json.load(f)\r\n        except Exception:\r\n            pass\r\n    return {sess[2]: [] for sess in SESSIONS}\r\n\r\ndef save_config(file_map):\r\n    try:\r\n        with open(CONFIG_FILE, \"w\") as f:\r\n            json.dump(file_map, f)\r\n    except Exception:\r\n        pass\r\n\r\nclass PyIcon(QWidget):\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n        self.setFixedSize(44, 44)\r\n\r\n    def paintEvent(self, event):\r\n        painter = QPainter(self)\r\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing)\r\n        rect = QRect(0, 0, 44, 44)\r\n        grad = QLinearGradient(0, 0, 44, 44)\r\n        grad.setColorAt(0, QColor(\"#a18cd1\"))\r\n        grad.setColorAt(1, QColor(\"#fbc2eb\"))\r\n        painter.setBrush(QBrush(grad))\r\n        painter.setPen(QColor(TILE_BORDER))\r\n        painter.drawRoundedRect(rect.adjusted(1, 1, -1, -1), 14, 14)\r\n        painter.setPen(QColor(\"#fff\"))\r\n        font = QFont(KALAMEH_FONT, 16, QFont.Weight.Bold)\r\n        painter.setFont(font)\r\n        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, \"Py\")\r\n\r\nclass ScriptTile(QWidget):\r\n    def __init__(self, path, run_callback, remove_callback, reorder_callback, file_list, parent=None):\r\n        super().__init__(parent)\r\n        self.path = path\r\n        self.run_callback = run_callback\r\n        self.remove_callback = remove_callback\r\n        self.reorder_callback = reorder_callback\r\n        self.file_list = file_list\r\n        self.setAcceptDrops(True)\r\n        self.setMinimumSize(260, 60)\r\n        self.setMaximumWidth(400)\r\n        self.setStyleSheet(f\"\"\"\r\n            QWidget {{\r\n                background: {TILE_BG};\r\n                border-radius: 14px;\r\n                border: 2px solid {TILE_BORDER};\r\n                margin-bottom: 28px;\r\n            }}\r\n            QWidget[dragOver=\"true\"] {{\r\n                border: 2.5px dashed {ACTIVE_TILE_BG};\r\n                background: {CARD_BG_HOVER};\r\n            }}\r\n            QWidget:hover {{\r\n                background: {TILE_BG_HOVER};\r\n                border: 2px solid {ACTIVE_TILE_BG};\r\n                box-shadow: 0 4px 32px #a18cd155;\r\n            }}\r\n        \"\"\")\r\n        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        layout = QHBoxLayout(self)\r\n        layout.setContentsMargins(13, 10, 13, 10)\r\n        layout.setSpacing(12)\r\n\r\n        # Py icon (rounded)\r\n        py_icon = PyIcon(self)\r\n        layout.addWidget(py_icon, alignment=Qt.AlignmentFlag.AlignVCenter)\r\n\r\n        # Filename (rounded bg, extra padding! Kalameh font)\r\n        label_name = QLabel(self)\r\n        filename = os.path.basename(path)\r\n        label_name.setText(filename)\r\n        label_name.setFont(QFont(KALAMEH_FONT, 15, QFont.Weight.Bold))\r\n        label_name.setStyleSheet(f\"\"\"\r\n            QLabel {{\r\n                color: {SOFT_TEXT};\r\n                background: transparent;\r\n                border: 2px solid {TILE_BORDER};\r\n                border-radius: 11px;\r\n                padding: 6px 28px 6px 28px;\r\n                font-family: \"{KALAMEH_FONT}\";\r\n            }}\r\n        \"\"\")\r\n        label_name.setToolTip(filename)\r\n        label_name.setWordWrap(True)\r\n        label_name.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)\r\n        layout.addWidget(label_name)\r\n\r\n        self.label_name = label_name\r\n        self.dragOver = False\r\n\r\n    def mousePressEvent(self, event):\r\n        if event.button() == Qt.MouseButton.LeftButton:\r\n            self._drag_start_pos = event.pos()\r\n        elif event.button() == Qt.MouseButton.RightButton:\r\n            self.remove_callback(self.path)\r\n        super().mousePressEvent(event)\r\n\r\n    def mouseMoveEvent(self, event):\r\n        if hasattr(self, '_drag_start_pos') and (event.pos() - self._drag_start_pos).manhattanLength() > QApplication.startDragDistance():\r\n            drag = QDrag(self)\r\n            mime = QMimeData()\r\n            idx = self.file_list.index(self.path)\r\n            mime.setText(str(idx))\r\n            drag.setMimeData(mime)\r\n            # Grab pixmap for drag image\r\n            pixmap = self.grab()\r\n            drag.setPixmap(pixmap)\r\n            drag.setHotSpot(event.pos())\r\n            drag.exec(Qt.DropAction.MoveAction)\r\n        super().mouseMoveEvent(event)\r\n\r\n    def mouseReleaseEvent(self, event):\r\n        if event.button() == Qt.MouseButton.LeftButton:\r\n            if not hasattr(self, '_drag_start_pos') or (event.pos() - self._drag_start_pos).manhattanLength() < QApplication.startDragDistance():\r\n                self.run_callback(self.path)\r\n        super().mouseReleaseEvent(event)\r\n\r\n    def dragEnterEvent(self, event):\r\n        if event.mimeData().hasText():\r\n            event.acceptProposedAction()\r\n            self.setProperty(\"dragOver\", True)\r\n            self.setStyle(self.style())\r\n        else:\r\n            event.ignore()\r\n\r\n    def dragLeaveEvent(self, event):\r\n        self.setProperty(\"dragOver\", False)\r\n        self.setStyle(self.style())\r\n\r\n    def dropEvent(self, event):\r\n        self.setProperty(\"dragOver\", False)\r\n        self.setStyle(self.style())\r\n        src_idx = int(event.mimeData().text())\r\n        dst_idx = self.file_list.index(self.path)\r\n        if src_idx != dst_idx:\r\n            self.reorder_callback(src_idx, dst_idx)\r\n        event.acceptProposedAction()\r\n\r\nclass GlassCard(QFrame):\r\n    def __init__(self, parent=None, min_height=180, pad_v=0):\r\n        super().__init__(parent)\r\n        self.setStyleSheet(f\"\"\"\r\n            QFrame {{\r\n                background: {CARD_BG};\r\n                border-radius: 18px;\r\n                box-shadow: 0 4px 32px #15152488;\r\n                padding-top: {pad_v}px;\r\n                padding-bottom: {pad_v}px;\r\n            }}\r\n        \"\"\")\r\n        self.setMinimumHeight(min_height)\r\n\r\nclass SessionCard(GlassCard):\r\n    def __init__(self, name, icon, idx, key, get_files, add_files, run_code, remove_file, handle_drop, reorder_files):\r\n        super().__init__()\r\n        self.setAcceptDrops(True)\r\n        self.handle_drop = handle_drop\r\n        self.name = name\r\n        self.icon = icon\r\n        self.get_files = get_files\r\n        self.add_files = add_files\r\n        self.run_code = run_code\r\n        self.remove_file = remove_file\r\n        self.idx = idx\r\n        self.reorder_files = reorder_files\r\n        self.key = key\r\n\r\n        content = QVBoxLayout()\r\n        # Header row\r\n        head = QHBoxLayout()\r\n        icon_label = QLabel(self.icon)\r\n        # Larger emoji font\r\n        icon_label.setStyleSheet(f\"font-size: 2.4em; font-family: '{KALAMEH_FONT}'; margin-right: 6px;\")\r\n        head.addWidget(icon_label)\r\n        # Session name in larger, bold Kalameh font\r\n        title = QLabel(self.name)\r\n        title.setFont(QFont(KALAMEH_FONT, 20, QFont.Weight.Bold))\r\n        title.setStyleSheet(f\"\"\"\r\n            font-size: 1.47em;\r\n            font-weight: bold;\r\n            color: {SOFT_TEXT};\r\n            margin-right: 10px;\r\n            font-family: \"{KALAMEH_FONT}\";\r\n        \"\"\")\r\n        head.addWidget(title)\r\n        # Short session code tag (FP1, Q, etc.)\r\n        code = QLabel(self.key)\r\n        code.setFont(QFont(KALAMEH_FONT, 15, QFont.Weight.Medium))\r\n        code.setStyleSheet(f\"\"\"\r\n            font-size: 1.13em;\r\n            color: {SUBTLE_TEXT};\r\n            margin-left: 0.7em;\r\n            font-family: \"{KALAMEH_FONT}\";\r\n        \"\"\")\r\n        head.addWidget(code)\r\n        head.addStretch(1)\r\n        add_btn = QPushButton(\"＋ Add Files\")\r\n        add_btn.setCursor(Qt.CursorShape.PointingHandCursor)\r\n        add_btn.setStyleSheet(f\"\"\"\r\n            QPushButton {{\r\n                background: {SESSION_GRADIENT[idx]};\r\n                color: #23233c;\r\n                border-radius: 8px;\r\n                padding: 4px 14px;\r\n                font-weight: 600;\r\n                font-family: \"{KALAMEH_FONT}\";\r\n            }}\r\n            QPushButton:hover {{\r\n                background: {ACCENT_GRADIENT};\r\n                color: #23233c;\r\n            }}\r\n        \"\"\")\r\n        add_btn.setFont(QFont(KALAMEH_FONT, 13, QFont.Weight.Bold))\r\n        add_btn.clicked.connect(lambda: self.add_files(self.key))\r\n        head.addWidget(add_btn)\r\n        content.addLayout(head)\r\n        # Tiles grid\r\n        self.grid = QGridLayout()\r\n        self.grid.setHorizontalSpacing(36)\r\n        self.grid.setVerticalSpacing(44)\r\n        self.grid.setContentsMargins(24, 24, 24, 24)\r\n        content.addLayout(self.grid)\r\n        self.setLayout(content)\r\n        self.refresh_tiles()\r\n\r\n    def refresh_tiles(self):\r\n        while self.grid.count():\r\n            item = self.grid.takeAt(0)\r\n            widget = item.widget()\r\n            if widget:\r\n                widget.deleteLater()\r\n        files = self.get_files(self.key)\r\n        cols = 5\r\n        for idx, f in enumerate(files):\r\n            tile = ScriptTile(\r\n                f,\r\n                run_callback=self.run_code,\r\n                remove_callback=lambda p, n=self.key: self.remove_file(n, p),\r\n                reorder_callback=self.reorder_files,\r\n                file_list=files,\r\n                parent=self\r\n            )\r\n            row, col = divmod(idx, cols)\r\n            self.grid.addWidget(tile, row, col, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)\r\n\r\n    def dragEnterEvent(self, event):\r\n        if event.mimeData().hasUrls() or event.mimeData().hasText():\r\n            event.acceptProposedAction()\r\n\r\n    def dropEvent(self, event):\r\n        files = []\r\n        if event.mimeData().hasUrls():\r\n            files = [u.toLocalFile() for u in event.mimeData().urls() if u.toLocalFile().endswith(\".py\")]\r\n        if files:\r\n            self.handle_drop(self.key, files)\r\n\r\nclass OutputDialog(QMessageBox):\r\n    def __init__(self, filename, out, err, full_path):\r\n        super().__init__()\r\n        self.setWindowTitle(f\"Output: {filename}\")\r\n        self.setIcon(QMessageBox.Icon.Information)\r\n        style = f\"\"\"\r\n        <style>\r\n        pre {{\r\n            background: {CARD_BG};\r\n            color: {SOFT_TEXT};\r\n            font-size: 1em;\r\n            padding: 8px;\r\n            border-radius: 6px;\r\n            font-family: 'Fira Mono', 'Consolas', monospace;\r\n        }}\r\n        .stderr {{\r\n            color: #f7797d;\r\n        }}\r\n        </style>\r\n        \"\"\"\r\n        html = f\"\"\"{style}\r\n        <b>STDOUT:</b>\r\n        <pre>{out if out.strip() else \"(none)\"}</pre>\r\n        <b class='stderr'>STDERR:</b>\r\n        <pre class='stderr'>{err if err.strip() else \"(none)\"}</pre>\r\n        <div style=\"font-size:0.9em;color:{SUBTLE_TEXT};\">{full_path}</div>\r\n        \"\"\"\r\n        self.setTextFormat(Qt.TextFormat.RichText)\r\n        self.setText(html)\r\n        self.setStandardButtons(QMessageBox.StandardButton.Ok)\r\n\r\nclass TopBar(QFrame):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setFixedHeight(64)\r\n        self.setStyleSheet(f\"\"\"\r\n            QFrame {{\r\n                background: {TOP_GRADIENT};\r\n                border-bottom-left-radius: 24px;\r\n                border-bottom-right-radius: 24px;\r\n            }}\r\n        \"\"\")\r\n        layout = QHBoxLayout()\r\n        layout.setContentsMargins(28, 10, 28, 10)\r\n        icon = QLabel(\"🏎️\")\r\n        icon.setFont(QFont(KALAMEH_FONT, 25, QFont.Weight.Bold))\r\n        icon.setStyleSheet(\"font-size: 2.2em; font-family: '{}';\".format(KALAMEH_FONT))\r\n        layout.addWidget(icon, alignment=Qt.AlignmentFlag.AlignVCenter)\r\n        title = QLabel(\"<b>Amir Formula</b>\")\r\n        title.setFont(QFont(KALAMEH_FONT, 25, QFont.Weight.Bold))\r\n        title.setStyleSheet(f\"font-size: 1.7em; color: {SOFT_TEXT}; font-weight: bold; font-family: '{KALAMEH_FONT}';\")\r\n        layout.addWidget(title)\r\n        layout.addStretch(1)\r\n        user = QLabel(\"AMYV7418\")\r\n        user.setFont(QFont(KALAMEH_FONT, 15, QFont.Weight.Bold))\r\n        user.setStyleSheet(f\"font-size: 1.08em; color: {SOFT_TEXT}; font-weight: bold; margin-right: 18px; font-family: '{KALAMEH_FONT}';\")\r\n        layout.addWidget(user)\r\n        avatar = QLabel()\r\n        avatar.setPixmap(QPixmap(32, 32))\r\n        avatar.setFixedSize(32, 32)\r\n        avatar.setStyleSheet(\"border-radius: 16px; background: #fff2;\")\r\n        layout.addWidget(avatar)\r\n        self.setLayout(layout)\r\n\r\nclass F1AnalysisApp(QMainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setWindowTitle(\"F1 Analysis\")\r\n        self.setWindowIcon(QIcon())\r\n        self.setMinimumSize(1300, 750)\r\n        self.file_map = load_config()\r\n        self.groups = {}\r\n\r\n        # Modern palette\r\n        pal = QPalette()\r\n        pal.setColor(QPalette.ColorRole.Window, QColor(\"#202036\"))\r\n        pal.setColor(QPalette.ColorRole.WindowText, QColor(SOFT_TEXT))\r\n        self.setPalette(pal)\r\n        self.setStyleSheet(f\"\"\"\r\n            QMainWindow {{ background: #202036; }}\r\n            QLabel, QTextEdit {{ color: {SOFT_TEXT}; font-size: 1.05em; font-family: '{KALAMEH_FONT}'; }}\r\n            QScrollArea {{ border: none; background: transparent; }}\r\n        \"\"\")\r\n\r\n        main_layout = QVBoxLayout()\r\n        main_layout.setSpacing(12)\r\n        main_layout.setContentsMargins(0, 0, 0, 0)\r\n\r\n        main_layout.addWidget(TopBar())\r\n\r\n        # Info block -- reduce height & font\r\n        info_card = GlassCard(min_height=30, pad_v=0)\r\n        info_layout = QHBoxLayout()\r\n        info_card.setLayout(info_layout)\r\n        hello = QLabel(\"Hello, AMYV7418! Welcome to F1 Analysis. Select or drag-and-drop Python scripts for each session. Click a tile to execute. Right-click to delete. Drag tiles to reorder.\")\r\n        hello.setFont(QFont(KALAMEH_FONT, 13))\r\n        hello.setStyleSheet(f\"font-size: 1.07em; color: {SOFT_TEXT}; margin: 0px; padding: 0px; font-family: '{KALAMEH_FONT}';\")\r\n        info_layout.setContentsMargins(6, 1, 6, 1)\r\n        info_layout.addWidget(hello)\r\n        info_layout.addStretch(1)\r\n        main_layout.addWidget(info_card)\r\n\r\n        # Scrollable session cards\r\n        scroll_area = QScrollArea()\r\n        scroll_area.setWidgetResizable(True)\r\n        scroll_content = QWidget()\r\n        session_layout = QVBoxLayout(scroll_content)\r\n        session_layout.setSpacing(18)\r\n        session_layout.setContentsMargins(20, 10, 20, 10)\r\n\r\n        # Cards for each session\r\n        for idx, (name, icon, key) in enumerate(SESSIONS):\r\n            group = SessionCard(\r\n                name=name,\r\n                icon=icon,\r\n                idx=idx,\r\n                key=key,\r\n                get_files=lambda n, m=self.file_map: m[n],\r\n                add_files=self.add_files,\r\n                run_code=self.run_code,\r\n                remove_file=self.remove_file,\r\n                handle_drop=self.handle_drop,\r\n                reorder_files=lambda src, dst, n=key: self.reorder_files(n, src, dst)\r\n            )\r\n            self.groups[key] = group\r\n            session_layout.addWidget(group)\r\n\r\n        session_layout.addStretch(1)\r\n        scroll_area.setWidget(scroll_content)\r\n        main_layout.addWidget(scroll_area)\r\n\r\n        # Footer -- reduce height & font\r\n        footer_card = GlassCard(min_height=35, pad_v=0)\r\n        footer_layout = QHBoxLayout()\r\n        footer_card.setLayout(footer_layout)\r\n        footer = QLabel(\"Amir Formula • Inspired by modern smart home dashboards • Powered by Python\")\r\n        footer.setFont(QFont(KALAMEH_FONT, 13))\r\n        footer.setStyleSheet(f\"color: {SUBTLE_TEXT}; font-size: 0.98em; margin: 0px; padding: 0px; font-family: '{KALAMEH_FONT}';\")\r\n        footer_layout.setContentsMargins(0, 0, 0, 0)\r\n        footer_layout.addWidget(footer, alignment=Qt.AlignmentFlag.AlignCenter)\r\n        main_layout.addWidget(footer_card, alignment=Qt.AlignmentFlag.AlignCenter)\r\n\r\n        container = QWidget()\r\n        container.setLayout(main_layout)\r\n        self.setCentralWidget(container)\r\n\r\n    def add_files(self, session):\r\n        files, _ = QFileDialog.getOpenFileNames(self, f\"Select Python files for {session}\", \"\",\r\n                                                \"Python Files (*.py);;All Files (*)\")\r\n        if files:\r\n            for file in files:\r\n                if file not in self.file_map[session]:\r\n                    self.file_map[session].append(file)\r\n            save_config(self.file_map)\r\n            self.groups[session].refresh_tiles()\r\n\r\n    def remove_file(self, session, file):\r\n        if file in self.file_map[session]:\r\n            self.file_map[session].remove(file)\r\n            save_config(self.file_map)\r\n            self.groups[session].refresh_tiles()\r\n\r\n    def run_code(self, file_path):\r\n        if not os.path.exists(file_path):\r\n            QMessageBox.critical(self, \"File not found\", f\"{file_path} does not exist.\")\r\n            return\r\n        try:\r\n            result = subprocess.run([sys.executable, file_path], capture_output=True, text=True)\r\n            out = result.stdout\r\n            err = result.stderr\r\n            dlg = OutputDialog(os.path.basename(file_path), out, err, file_path)\r\n            dlg.exec()\r\n        except Exception as e:\r\n            QMessageBox.critical(self, \"Execution Error\", str(e))\r\n\r\n    def handle_drop(self, session, files):\r\n        changed = False\r\n        for f in files:\r\n            if f.endswith(\".py\") and f not in self.file_map[session]:\r\n                self.file_map[session].append(f)\r\n                changed = True\r\n        if changed:\r\n            save_config(self.file_map)\r\n            self.groups[session].refresh_tiles()\r\n\r\n    def reorder_files(self, session, src_idx, dst_idx):\r\n        if src_idx == dst_idx:\r\n            return\r\n        files = self.file_map[session]\r\n        file = files.pop(src_idx)\r\n        files.insert(dst_idx, file)\r\n        save_config(self.file_map)\r\n        self.groups[session].refresh_tiles()\r\n\r\nif __name__ == \"__main__\":\r\n    app = QApplication(sys.argv)\r\n    win = F1AnalysisApp()\r\n    win.show()\r\n    sys.exit(app.exec())","size_bytes":20121},"attached_assets/stress Index_1753515777343.py":{"content":"import fastf1 as ff1\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom matplotlib import cm\r\n\r\n# ==============================\r\n# تنظیمات اولیه\r\n# ==============================\r\nff1.Cache.clear_cache()  # پاک‌سازی کش برای اطمینان از داده‌های به‌روز\r\nDEFAULT_YEAR = 2024\r\nDEFAULT_GRAND_PRIX = 'Canada'\r\nDEFAULT_SESSION_TYPE = 'R'  # Race\r\n\r\n# ==============================\r\n# توابع تحلیل و محاسبه\r\n# ==============================\r\n\r\ndef load_session_data(year, grand_prix, session_type):\r\n    \"\"\"Load the F1 session data.\"\"\"\r\n    session = ff1.get_session(year, grand_prix, session_type)\r\n    session.load()\r\n    return session\r\n\r\ndef calculate_driver_stress_index(session):\r\n    \"\"\"Calculate a Driver Stress Index (DSI) for all drivers.\"\"\"\r\n    drivers = session.drivers\r\n    results = []\r\n\r\n    for driver in drivers:\r\n        driver_laps = session.laps.pick_driver(driver)\r\n        fastest_lap = driver_laps.pick_fastest()\r\n\r\n        if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\r\n            continue\r\n\r\n        try:\r\n            telemetry = fastest_lap.get_car_data().add_distance()\r\n        except KeyError:\r\n            continue\r\n\r\n        # تحلیل بخش‌های کلیدی\r\n        speed_data = telemetry['Speed']\r\n        brake_data = telemetry['Brake']\r\n        throttle_data = telemetry['Throttle']\r\n        distance_data = telemetry['Distance']\r\n\r\n        # بهبودهای جدید:\r\n        # 1. محاسبه دقیق‌تر طول مسیر و فاصله برای تحلیل تنش\r\n        total_distance = distance_data.max() - distance_data.min()\r\n\r\n        # 2. وزن‌دهی شتاب‌گیری و ترمزگیری بر اساس طول مسیر\r\n        braking_weighted = (brake_data.sum() * (distance_data.diff().mean())) / total_distance * 100\r\n        high_throttle_weighted = (len(throttle_data[throttle_data > 90]) * distance_data.diff().mean()) / total_distance * 100\r\n\r\n        # 3. استفاده از میانه سرعت در مقاطع بحرانی\r\n        critical_speed_median = speed_data[(brake_data > 0) | (throttle_data > 90)].median()\r\n\r\n        # شاخص تنش راننده\r\n        stress_index = (braking_weighted + (100 - high_throttle_weighted)) / critical_speed_median\r\n\r\n        driver_name = session.get_driver(driver)['LastName'][:3].upper()\r\n        team_name = session.get_driver(driver)['TeamName']\r\n\r\n        results.append({\r\n            'Driver': driver_name,\r\n            'Team': team_name,\r\n            'Braking %': braking_weighted,\r\n            'High Throttle %': high_throttle_weighted,\r\n            'Critical Speed Median (km/h)': critical_speed_median,\r\n            'Driver Stress Index': stress_index\r\n        })\r\n\r\n    return pd.DataFrame(results)\r\n\r\n# ==============================\r\n# توابع رسم نمودار\r\n# ==============================\r\n\r\ndef plot_stress_index(df_stress_index, grand_prix, year):\r\n    \"\"\"Plot Driver Stress Index with critical metrics and enhanced UI.\"\"\"\r\n    fig, ax = plt.subplots(figsize=(12, 8), facecolor='black')\r\n    ax.set_facecolor('black')\r\n    fig.suptitle(f'{grand_prix} {year} - Driver Stress Index', color='white', fontsize=20, y=0.92)\r\n\r\n    # افزودن واترمارک\r\n    fig.text(0.5, 0.5, 'F1 DATA IQ', fontsize=80, color='white', ha='center', va='center', alpha=0.2)\r\n\r\n    # Bar Chart: Driver Stress Index\r\n    colors = cm.plasma(df_stress_index['Driver Stress Index'] / df_stress_index['Driver Stress Index'].max())\r\n    bars = ax.bar(df_stress_index['Driver'], df_stress_index['Driver Stress Index'], color=colors)\r\n\r\n    # Customize appearance\r\n    ax.set_title('Driver Stress Index Analysis', color='white', fontsize=16, pad=10)\r\n    ax.set_xlabel('Driver', color='white', fontsize=12)\r\n    ax.set_ylabel('Stress Index', color='white', fontsize=12)\r\n    ax.tick_params(axis='x', colors='white', rotation=45, labelsize=10)\r\n    ax.tick_params(axis='y', colors='white', labelsize=10)\r\n    ax.grid(color='gray', linestyle='--', linewidth=0.5, alpha=0.7)\r\n\r\n    # Annotate bars with critical metrics\r\n    for bar, critical_speed in zip(bars, df_stress_index['Critical Speed Median (km/h)']):\r\n        ax.text(bar.get_x() + bar.get_width() / 2, bar.get_height(),\r\n                f'{critical_speed:.1f} km/h', ha='center', va='bottom', fontsize=9, color='yellow')\r\n\r\n    # اضافه کردن میانگین خط\r\n    mean_value = df_stress_index['Driver Stress Index'].mean()\r\n    ax.axhline(mean_value, color='red', linestyle='--', linewidth=1, label=f'Mean: {mean_value:.2f}')\r\n    ax.legend(facecolor='black', edgecolor='white', fontsize=10)\r\n\r\n    # اضافه کردن جزئیات بصری بیشتر\r\n    for spine in ax.spines.values():\r\n        spine.set_edgecolor('white')\r\n\r\n    plt.tight_layout(rect=[0, 0, 1, 0.95])\r\n    plt.savefig('driver_stress_index_enhanced.png', dpi=300, facecolor=fig.get_facecolor())\r\n    plt.show()\r\n\r\n# ==============================\r\n# اجرای اصلی\r\n# ==============================\r\n\r\n# بارگذاری داده‌ها\r\nsession = load_session_data(DEFAULT_YEAR, DEFAULT_GRAND_PRIX, DEFAULT_SESSION_TYPE)\r\n\r\n# محاسبه تنش راننده\r\ndf_stress_index = calculate_driver_stress_index(session)\r\ndf_stress_index = df_stress_index.sort_values(by='Driver Stress Index', ascending=False)\r\n\r\n# نمایش جدول نتایج\r\nprint(df_stress_index)\r\n\r\n# رسم نمودار\r\nplot_stress_index(df_stress_index, DEFAULT_GRAND_PRIX, DEFAULT_YEAR)\r\n","size_bytes":5546},"attached_assets/track_dominance (2)_1753442477646.py":{"content":"import fastf1\r\nfrom fastf1 import plotting\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.lines import Line2D\r\nimport numpy as np\r\nfrom tkinter import *\r\nfrom tkinter import ttk\r\nfrom tkinter import messagebox\r\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\r\nfrom tkinter.filedialog import asksaveasfilename\r\nimport os\r\nimport matplotlib.font_manager as fm\r\nfrom scipy.interpolate import interp1d\r\n\r\n# DARK MODE & FONT\r\nKALAMEH_FONT_NAME = \"Kalameh\"\r\nfont_paths = fm.findSystemFonts(fontpaths=None, fontext='ttf')\r\nkalameh_path = None\r\nfor path in font_paths:\r\n    if \"Kalameh\" in os.path.basename(path):\r\n        kalameh_path = path\r\n        break\r\n\r\nif kalameh_path:\r\n    plt.rcParams['font.family'] = KALAMEH_FONT_NAME\r\n    fm.fontManager.addfont(kalameh_path)\r\nelse:\r\n    plt.rcParams['font.family'] = 'sans-serif'\r\n\r\nplt.style.use('dark_background')\r\nplt.rcParams.update({\r\n    'axes.facecolor': '#18191A',\r\n    'figure.facecolor': '#18191A',\r\n    'axes.edgecolor': '#404040',\r\n    'axes.labelcolor': 'white',\r\n    'text.color': 'white',\r\n    'xtick.color': 'white',\r\n    'ytick.color': 'white',\r\n    'legend.facecolor': '#23272F',\r\n    'legend.edgecolor': '#404040',\r\n    'savefig.facecolor': '#18191A',\r\n    'savefig.edgecolor': '#18191A'\r\n})\r\n\r\nDARK_BG = \"#18191A\"\r\nDARK_FG = \"#FFFFFF\"\r\nDARK_ENTRY_BG = \"#23272F\"\r\nDARK_HL = \"#323232\"\r\nFONT_FAMILY = (KALAMEH_FONT_NAME, 13) if kalameh_path else (\"Arial\", 13)\r\nTITLE_FONT = (KALAMEH_FONT_NAME, 15, \"bold\") if kalameh_path else (\"Arial\", 15, \"bold\")\r\n\r\ncache_folder = r\"C:\\Users\\AMYV\\Desktop\\AF\\f1_analysis\\Cache\"\r\nos.makedirs(cache_folder, exist_ok=True)\r\nos.environ['FASTF1_CACHE'] = cache_folder\r\nplotting.setup_mpl(color_scheme=None, misc_mpl_mods=False)\r\n\r\nyears = list(range(2020, 2026))\r\nsessions = ['Q', 'R', 'FP1', 'FP2', 'FP3', 'Sprint', 'Sprint Qualifying', 'Practice 1', 'Practice 2', 'Practice 3']\r\ngrands_prix = [\r\n    'Australian Grand Prix', 'Chinese Grand Prix', 'Japanese Grand Prix', 'Bahrain Grand Prix', 'Saudi Arabian Grand Prix',\r\n    'Miami Grand Prix', 'Emilia Romagna Grand Prix', 'Monaco Grand Prix', 'Spanish Grand Prix', 'Canadian Grand Prix',\r\n    'Austrian Grand Prix', 'British Grand Prix', 'Belgian Grand Prix', 'Hungarian Grand Prix', 'Dutch Grand Prix',\r\n    'Italian Grand Prix', 'Azerbaijan Grand Prix', 'Singapore Grand Prix', 'United States Grand Prix', 'Mexico City Grand Prix',\r\n    'São Paulo Grand Prix', 'Las Vegas Grand Prix', 'Qatar Grand Prix', 'Abu Dhabi Grand Prix'\r\n]\r\n\r\nteam_colors = {\r\n    'Mercedes': '#00D2BE',\r\n    'Red Bull Racing': '#1E41FF',\r\n    'Ferrari': '#DC0000',\r\n    'McLaren': '#FF8700',\r\n    'Alpine': '#0090FF',\r\n    'Aston Martin': '#006F62',\r\n    'Haas': '#808080',\r\n    'Racing Bulls': '#1660AD',\r\n    'Williams': '#87cefa',\r\n    'Kick Sauber': '#00e701'\r\n}\r\n\r\ndef get_driver_team(driver):\r\n    driver_teams = {\r\n        'VER': 'Red Bull Racing',\r\n        'LAW': 'Red Bull Racing',\r\n        'LEC': 'Ferrari',\r\n        'HAM': 'Ferrari',\r\n        'NOR': 'McLaren',\r\n        'PIA': 'McLaren',\r\n        'RUS': 'Mercedes',\r\n        'ANT': 'Mercedes',\r\n        'ALO': 'Aston Martin',\r\n        'STR': 'Aston Martin',\r\n        'GAS': 'Alpine',\r\n        'DOO': 'Alpine',\r\n        'OCO': 'Haas',\r\n        'BEA': 'Haas',\r\n        'TSU': 'Racing Bulls',\r\n        'HAD': 'Racing Bulls',\r\n        'ALB': 'Williams',\r\n        'SAI': 'Williams',\r\n        'HUL': 'Kick Sauber',\r\n        'BOR': 'Kick Sauber'\r\n    }\r\n    return driver_teams.get(driver, 'Unknown')\r\n\r\ndef interpolate_track(X, Y, num_points=2000):\r\n    mask = ~(np.isnan(X) | np.isnan(Y))\r\n    X = X[mask]\r\n    Y = Y[mask]\r\n    dist = np.sqrt(np.diff(X)**2 + np.diff(Y)**2)\r\n    cumdist = np.insert(np.cumsum(dist), 0, 0)\r\n    fx = interp1d(cumdist, X, kind='cubic')\r\n    fy = interp1d(cumdist, Y, kind='cubic')\r\n    uniform_dist = np.linspace(cumdist[0], cumdist[-1], num_points)\r\n    X_new = fx(uniform_dist)\r\n    Y_new = fy(uniform_dist)\r\n    return X_new, Y_new, uniform_dist\r\n\r\ndef plot_telemetry(year, grand_prix, session_name, selected_drivers, for_export=False):\r\n    if grand_prix == 'Pre-Season Testing':\r\n        session = fastf1.get_testing_session(year, 1, session_name)\r\n    else:\r\n        session = fastf1.get_session(year, grand_prix, session_name)\r\n    session.load()\r\n\r\n    fig, ax = plt.subplots(figsize=(18, 10) if for_export else (10, 6))\r\n    num_minisectors = 200\r\n    mini_sectors = np.linspace(0, 1, num_minisectors)\r\n    all_telemetry = {}\r\n    fastest_laps = {}\r\n    driver_colors = {}\r\n\r\n    for driver in selected_drivers:\r\n        laps = session.laps.pick_drivers(driver)\r\n        fastest_lap = laps.pick_fastest()\r\n        telemetry = fastest_lap.get_telemetry().copy()\r\n        fastest_laps[driver] = fastest_lap\r\n        X_new, Y_new, dist = interpolate_track(telemetry['X'].values, telemetry['Y'].values)\r\n        speed_interp = interp1d(np.linspace(0, 1, len(telemetry)), telemetry['Speed'].values, kind='cubic')\r\n        speed_new = speed_interp(np.linspace(0, 1, len(X_new)))\r\n        telemetry_interp = {\r\n            'X': X_new,\r\n            'Y': Y_new,\r\n            'Speed': speed_new,\r\n            'Distance': np.linspace(0, 1, len(X_new)),\r\n        }\r\n        all_telemetry[driver] = telemetry_interp\r\n\r\n    for driver in selected_drivers:\r\n        driver_colors[driver] = team_colors.get(get_driver_team(driver), \"#DDDDDD\")\r\n\r\n    team_times = {}\r\n    for driver in selected_drivers:\r\n        team = get_driver_team(driver)\r\n        if team not in team_times:\r\n            team_times[team] = []\r\n        team_times[team].append(driver)\r\n    for team, drivers in team_times.items():\r\n        if len(drivers) > 1:\r\n            drivers_with_times = [(driver, fastest_laps[driver]['LapTime']) for driver in drivers]\r\n            drivers_with_times.sort(key=lambda x: x[1])\r\n            for i in range(1, len(drivers_with_times)):\r\n                driver_colors[drivers_with_times[i][0]] = '#ED3EF7'\r\n\r\n    for i in range(num_minisectors - 1):\r\n        fastest_driver = None\r\n        fastest_speed = -1\r\n        fastest_sector = None\r\n        for driver, tel in all_telemetry.items():\r\n            mask = (tel['Distance'] >= mini_sectors[i]) & (tel['Distance'] < mini_sectors[i+1])\r\n            if not np.any(mask):\r\n                continue\r\n            mean_speed = tel['Speed'][mask].mean()\r\n            if mean_speed > fastest_speed:\r\n                fastest_speed = mean_speed\r\n                fastest_driver = driver\r\n                fastest_sector = (tel['X'][mask], tel['Y'][mask])\r\n        if fastest_sector is not None and fastest_driver is not None:\r\n            color = driver_colors[fastest_driver]\r\n            ax.plot(fastest_sector[0], fastest_sector[1], color=color, linewidth=4 if for_export else 2.5, alpha=0.92, solid_capstyle='round')\r\n\r\n    for driver, tel in all_telemetry.items():\r\n        ax.plot(tel['X'], tel['Y'], color=driver_colors[driver], linewidth=1.5, alpha=0.2, zorder=-1)\r\n\r\n    ax.set_aspect('equal', adjustable='datalim')\r\n    ax.axis('off')\r\n\r\n    title_font = {'fontsize': 28 if for_export else 20, 'fontweight': 'bold'}\r\n    if kalameh_path:\r\n        title_font['fontname'] = KALAMEH_FONT_NAME\r\n    plt.title(\"Track Dominance Map of Fastest Mini-Sectors\", color='white', **title_font, pad=22)\r\n    plt.suptitle(f\"Track Dominance by Mini Sectors ({year}) - {grand_prix} - {session_name}\", color='white', fontsize=15 if for_export else 12, fontname=KALAMEH_FONT_NAME if kalameh_path else None)\r\n\r\n    # Enhanced Fastest Lap Box\r\n    annotation = \"\"\r\n    for driver, lap in fastest_laps.items():\r\n        lap_time = lap['LapTime']\r\n        lap_time_str = f\"{int(lap_time.total_seconds() // 60)}:{int(lap_time.total_seconds() % 60):02}.{int((lap_time.total_seconds() * 1000) % 1000):03}\"\r\n        annotation += f\"{driver}  |  {lap_time_str}\\n\"\r\n\r\n    # FASTEST LAP BOX DESIGN: Reduced size, modern box, thin colored border.\r\n    boxprops = dict(\r\n        boxstyle=\"round,pad=0.25\", \r\n        facecolor=\"#24242A\", \r\n        edgecolor=\"#00D2BE\", \r\n        linewidth=2, \r\n        alpha=0.92\r\n    )\r\n    ax.text(\r\n        -0.05, 0.97, annotation.strip(),\r\n        fontsize=18 if for_export else 17,\r\n        fontweight='bold',\r\n        bbox=boxprops,\r\n        verticalalignment='top',\r\n        horizontalalignment='left',\r\n        transform=ax.transAxes,\r\n        fontname=KALAMEH_FONT_NAME if kalameh_path else None,\r\n        color='#F0F0F0',\r\n        linespacing=1.3\r\n    )\r\n\r\n    legend_lines = [Line2D([0], [0], color=driver_colors[driver], lw=7 if for_export else 4) for driver in selected_drivers]\r\n    legend_labels = selected_drivers\r\n    leg = ax.legend(legend_lines, legend_labels, loc='lower center', bbox_to_anchor=(0.5, -0.08), fontsize=18 if for_export else 12,\r\n                    ncol=4, facecolor='#23272F', edgecolor='#404040', labelcolor='white', framealpha=0.7)\r\n    plt.setp(leg.get_texts(), fontname=KALAMEH_FONT_NAME if kalameh_path else None)\r\n\r\n    # --------- WATERMARK: smaller, bolder, less width ---------\r\n    watermark_text = \"@Amir_Formula\"\r\n    if kalameh_path:\r\n        watermark_font = fm.FontProperties(fname=kalameh_path, size=80 if for_export else 60, weight='bold')\r\n    else:\r\n        watermark_font = fm.FontProperties(size=80 if for_export else 60, weight='bold')\r\n    ax.text(0.5, 0.5, watermark_text,\r\n            color='#FFFFFF', alpha=0.25,\r\n            fontsize=80 if for_export else 60,\r\n            fontproperties=watermark_font,\r\n            ha='center', va='center', rotation=0, zorder=999,\r\n            transform=ax.transAxes, clip_on=False,\r\n            fontweight=\"bold\",\r\n            bbox=dict(boxstyle=\"round,pad=0.6\", fc=\"none\", ec=\"none\", alpha=0))\r\n\r\n    return fig\r\n\r\ndef update_drivers():\r\n    year = int(year_var.get())\r\n    grand_prix = grand_prix_var.get()\r\n    session_name = session_var.get()\r\n    try:\r\n        if grand_prix == 'Pre-Season Testing':\r\n            session = fastf1.get_testing_session(year, 1, session_name)\r\n        else:\r\n            session = fastf1.get_session(year, grand_prix, session_name)\r\n        session.load()\r\n        available_drivers = session.results['Abbreviation'].tolist()\r\n    except Exception as e:\r\n        messagebox.showerror(\"Error\", f\"Could not load session: {e}\")\r\n        return\r\n\r\n    for widget in drivers_frame.winfo_children():\r\n        widget.destroy()\r\n\r\n    driver_vars.clear()\r\n    for driver in available_drivers:\r\n        var = IntVar()\r\n        chk = Checkbutton(drivers_frame, text=driver, variable=var,\r\n                          bg=DARK_BG, fg=DARK_FG, selectcolor=DARK_ENTRY_BG, font=FONT_FAMILY, activebackground=DARK_HL,\r\n                          highlightthickness=0, bd=0)\r\n        chk.var = var\r\n        chk.pack(anchor=W, pady=2)\r\n        driver_vars[driver] = var\r\n\r\ndef show_plot_page(selected_drivers):\r\n    plot_window = Toplevel(root)\r\n    plot_window.title(\"Track Dominance Map\")\r\n    plot_window.configure(bg=DARK_BG)\r\n    plot_window.geometry(\"1650x900\")\r\n\r\n    fig = plot_telemetry(int(year_var.get()), grand_prix_var.get(), session_var.get(), selected_drivers)\r\n    canvas = FigureCanvasTkAgg(fig, master=plot_window)\r\n    canvas.draw()\r\n    widget = canvas.get_tk_widget()\r\n    widget.pack(side=TOP, fill=BOTH, expand=1)\r\n    widget.configure(bg=DARK_BG)\r\n\r\n    footer = Frame(plot_window, bg=DARK_BG)\r\n    footer.pack(fill=X, side=BOTTOM)\r\n    Button(footer, text=\"Close\", command=plot_window.destroy, bg=\"#ED3EF7\", fg=DARK_BG, font=FONT_FAMILY, activebackground=\"#bb29b6\", width=9, height=1).pack(side=RIGHT, padx=28, pady=12)\r\n    Button(footer, text=\"Export as PNG (Full Screen)\", command=lambda: export_as_png(selected_drivers), bg=\"#00D2BE\", fg=DARK_BG, font=FONT_FAMILY, activebackground=\"#00AFA3\", width=22, height=1).pack(side=RIGHT, padx=18, pady=12)\r\n\r\ndef export_as_png(selected_drivers):\r\n    fig_export = plot_telemetry(int(year_var.get()), grand_prix_var.get(), session_var.get(), selected_drivers, for_export=True)\r\n    year = year_var.get()\r\n    grand_prix = grand_prix_var.get()\r\n    session = session_var.get()\r\n    drivers = \" & \".join(selected_drivers)\r\n    default_filename = f\"{year}-{grand_prix}-{session}-track-dominance-{drivers}.png\".replace(\" \", \"_\")\r\n    export_dir = r\"C:\\Users\\AMYV\\Desktop\\AF\\Exports\"\r\n    os.makedirs(export_dir, exist_ok=True)\r\n    file_path = os.path.join(export_dir, default_filename)\r\n    fig_export.savefig(file_path, dpi=200, bbox_inches='tight', pad_inches=0.1, facecolor='#18191A')\r\n    plt.close(fig_export)\r\n    messagebox.showinfo(\"Exported\", f\"Plot saved at:\\n{file_path}\")\r\n\r\ndef update_plot():\r\n    selected_drivers = [driver for driver, var in driver_vars.items() if var.get() == 1]\r\n    if len(selected_drivers) < 2:\r\n        messagebox.showerror(\"Error\", \"Please select at least two drivers.\")\r\n        return\r\n    show_plot_page(selected_drivers)\r\n\r\n# --------- TKINTER GUI ---------\r\ndriver_vars = {}\r\n\r\nroot = Tk()\r\nroot.title(\"Track Dominance Map of Fastest Mini-Sectors\")\r\nroot.configure(bg=DARK_BG)\r\nroot.geometry(\"1100x680\")\r\nroot.option_add(\"*Font\", FONT_FAMILY)\r\nroot.option_add(\"*Background\", DARK_BG)\r\nroot.option_add(\"*Foreground\", DARK_FG)\r\n\r\nstyle = ttk.Style()\r\nstyle.theme_use('clam')\r\nstyle.configure(\"TCombobox\",\r\n                fieldbackground=DARK_ENTRY_BG,\r\n                background=DARK_ENTRY_BG,\r\n                foreground=DARK_FG,\r\n                selectbackground=DARK_ENTRY_BG,\r\n                selectforeground=DARK_FG,\r\n                font=FONT_FAMILY)\r\nstyle.map(\"TCombobox\", fieldbackground=[('readonly', DARK_ENTRY_BG)])\r\nstyle.configure('TLabel', background=DARK_BG, foreground=DARK_FG, font=FONT_FAMILY)\r\nstyle.configure('TButton', background=DARK_ENTRY_BG, foreground=DARK_FG, font=FONT_FAMILY)\r\nstyle.configure('TFrame', background=DARK_BG)\r\n\r\napp_title = Label(root, text=\"Track Dominance Map of Fastest Mini-Sectors\", font=TITLE_FONT, bg=DARK_BG, fg=\"#00D2BE\")\r\napp_title.pack(pady=(14, 2))\r\n\r\ncontrols_frame = Frame(root, bg=DARK_BG)\r\ncontrols_frame.pack(side=LEFT, fill=Y, padx=18, pady=16)\r\n\r\ndrivers_frame = Frame(root, bg=DARK_BG)\r\ndrivers_frame.pack(side=RIGHT, fill=Y, padx=18, pady=16, expand=True)\r\n\r\nyear_var = StringVar()\r\ngrand_prix_var = StringVar()\r\nsession_var = StringVar()\r\n\r\nLabel(controls_frame, text=\"Year:\", bg=DARK_BG, fg=DARK_FG, font=FONT_FAMILY).grid(row=0, column=0, padx=5, pady=12, sticky=E)\r\nyear_menu = ttk.Combobox(controls_frame, textvariable=year_var, values=years, font=FONT_FAMILY, state=\"readonly\", width=18)\r\nyear_menu.grid(row=0, column=1, padx=5, pady=12, sticky=W)\r\n\r\nLabel(controls_frame, text=\"Grand Prix:\", bg=DARK_BG, fg=DARK_FG, font=FONT_FAMILY).grid(row=1, column=0, padx=5, pady=12, sticky=E)\r\ngrand_prix_menu = ttk.Combobox(controls_frame, textvariable=grand_prix_var, values=grands_prix, font=FONT_FAMILY, state=\"readonly\", width=18)\r\ngrand_prix_menu.grid(row=1, column=1, padx=5, pady=12, sticky=W)\r\n\r\nLabel(controls_frame, text=\"Session:\", bg=DARK_BG, fg=DARK_FG, font=FONT_FAMILY).grid(row=2, column=0, padx=5, pady=12, sticky=E)\r\nsession_menu = ttk.Combobox(controls_frame, textvariable=session_var, values=sessions, font=FONT_FAMILY, state=\"readonly\", width=18)\r\nsession_menu.grid(row=2, column=1, padx=5, pady=12, sticky=W)\r\n\r\nButton(controls_frame, text=\"Update Drivers\", command=update_drivers, bg=DARK_ENTRY_BG, fg=DARK_FG, font=FONT_FAMILY, activebackground=DARK_HL, width=18, height=1).grid(row=3, column=0, columnspan=2, pady=16)\r\nButton(controls_frame, text=\"Generate Plot\", command=update_plot, bg=\"#00D2BE\", fg=DARK_BG, font=FONT_FAMILY, activebackground=\"#00AFA3\", width=18, height=1).grid(row=4, column=0, columnspan=2, pady=10)\r\n\r\nLabel(drivers_frame, text=\"Select Drivers:\", bg=DARK_BG, fg=\"#00D2BE\", font=TITLE_FONT).pack(pady=(2, 8), anchor=W)\r\n\r\nroot.mainloop()","size_bytes":15749},"utils/advanced_analytics.py":{"content":"\"\"\"\nAdvanced F1 Analytics Module\nProvides comprehensive driver performance metrics, weather analysis, and race statistics\n\"\"\"\n\nimport fastf1\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import zscore\nfrom datetime import datetime, timedelta\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nclass AdvancedF1Analytics:\n    \"\"\"Advanced analytics for F1 data with comprehensive performance metrics\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        self.laps = session.laps\n        self.results = session.results\n        \n    def calculate_driver_consistency(self, driver_code):\n        \"\"\"Calculate driver consistency metrics across all laps\"\"\"\n        driver_laps = self.laps.pick_drivers(driver_code)\n        valid_laps = driver_laps[driver_laps['LapTime'].notna()]\n        \n        if len(valid_laps) < 3:\n            return None\n            \n        lap_times = valid_laps['LapTime'].dt.total_seconds()\n        \n        return {\n            'mean_lap_time': lap_times.mean(),\n            'std_deviation': lap_times.std(),\n            'coefficient_variation': lap_times.std() / lap_times.mean(),\n            'fastest_lap': lap_times.min(),\n            'slowest_lap': lap_times.max(),\n            'consistency_score': 1 / (1 + lap_times.std()),\n            'total_laps': len(valid_laps)\n        }\n    \n    def analyze_tire_degradation(self, driver_code):\n        \"\"\"Analyze tire degradation patterns for a driver\"\"\"\n        driver_laps = self.laps.pick_drivers(driver_code)\n        \n        degradation_data = []\n        \n        for compound in driver_laps['Compound'].unique():\n            if pd.isna(compound):\n                continue\n                \n            compound_laps = driver_laps[driver_laps['Compound'] == compound]\n            if len(compound_laps) < 2:\n                continue\n                \n            # Calculate degradation rate\n            lap_times = compound_laps['LapTime'].dt.total_seconds()\n            lap_numbers = range(len(lap_times))\n            \n            if len(lap_times) > 1:\n                degradation_rate = np.polyfit(lap_numbers, lap_times, 1)[0]\n                \n                degradation_data.append({\n                    'compound': compound,\n                    'stint_length': len(compound_laps),\n                    'degradation_rate': degradation_rate,\n                    'initial_pace': lap_times.iloc[0] if len(lap_times) > 0 else None,\n                    'final_pace': lap_times.iloc[-1] if len(lap_times) > 0 else None,\n                    'total_degradation': lap_times.iloc[-1] - lap_times.iloc[0] if len(lap_times) > 1 else 0\n                })\n        \n        return degradation_data\n    \n    def calculate_sector_dominance(self):\n        \"\"\"Calculate which drivers dominate each sector\"\"\"\n        sector_data = {\n            'Sector1': {},\n            'Sector2': {},\n            'Sector3': {}\n        }\n        \n        for driver in self.laps['Driver'].unique():\n            if pd.isna(driver):\n                continue\n                \n            driver_laps = self.laps.pick_drivers(driver)\n            \n            for sector in ['Sector1Time', 'Sector2Time', 'Sector3Time']:\n                valid_times = driver_laps[sector].dropna()\n                if len(valid_times) > 0:\n                    sector_name = sector.replace('Time', '')\n                    sector_data[sector_name][driver] = {\n                        'best_time': valid_times.min().total_seconds(),\n                        'average_time': valid_times.mean().total_seconds(),\n                        'consistency': valid_times.std().total_seconds()\n                    }\n        \n        return sector_data\n    \n    def analyze_overtaking_patterns(self):\n        \"\"\"Analyze overtaking and position changes during the race\"\"\"\n        if not hasattr(self.session, 'laps') or self.session.laps.empty:\n            return {}\n            \n        overtaking_data = {}\n        \n        for lap_num in range(1, self.laps['LapNumber'].max() + 1):\n            lap_data = self.laps[self.laps['LapNumber'] == lap_num]\n            \n            if len(lap_data) > 1:\n                # Calculate position changes\n                if lap_num > 1:\n                    prev_lap = self.laps[self.laps['LapNumber'] == lap_num - 1]\n                    \n                    for driver in lap_data['Driver'].unique():\n                        if pd.isna(driver):\n                            continue\n                            \n                        current_pos = lap_data[lap_data['Driver'] == driver]['Position'].iloc[0] if len(lap_data[lap_data['Driver'] == driver]) > 0 else None\n                        prev_pos = prev_lap[prev_lap['Driver'] == driver]['Position'].iloc[0] if len(prev_lap[prev_lap['Driver'] == driver]) > 0 else None\n                        \n                        if current_pos is not None and prev_pos is not None:\n                            position_change = prev_pos - current_pos\n                            \n                            if driver not in overtaking_data:\n                                overtaking_data[driver] = {\n                                    'positions_gained': 0,\n                                    'positions_lost': 0,\n                                    'overtakes': [],\n                                    'net_position_change': 0\n                                }\n                            \n                            if position_change > 0:\n                                overtaking_data[driver]['positions_gained'] += position_change\n                                overtaking_data[driver]['overtakes'].append({\n                                    'lap': lap_num,\n                                    'positions': position_change,\n                                    'type': 'gained'\n                                })\n                            elif position_change < 0:\n                                overtaking_data[driver]['positions_lost'] += abs(position_change)\n                                overtaking_data[driver]['overtakes'].append({\n                                    'lap': lap_num,\n                                    'positions': abs(position_change),\n                                    'type': 'lost'\n                                })\n        \n        # Calculate net position changes\n        for driver in overtaking_data:\n            overtaking_data[driver]['net_position_change'] = (\n                overtaking_data[driver]['positions_gained'] - \n                overtaking_data[driver]['positions_lost']\n            )\n        \n        return overtaking_data\n    \n    def create_advanced_telemetry_comparison(self, driver1, driver2, lap_number=None):\n        \"\"\"Create advanced telemetry comparison with multiple metrics\"\"\"\n        \n        if lap_number is None:\n            # Use fastest laps\n            lap1 = self.laps.pick_drivers(driver1).pick_fastest()\n            lap2 = self.laps.pick_drivers(driver2).pick_fastest()\n        else:\n            lap1 = self.laps.pick_drivers(driver1).pick_lap(lap_number)\n            lap2 = self.laps.pick_drivers(driver2).pick_lap(lap_number)\n        \n        try:\n            telemetry1 = lap1.get_telemetry()\n            telemetry2 = lap2.get_telemetry()\n        except:\n            return None\n        \n        # Create comprehensive telemetry comparison\n        fig = make_subplots(\n            rows=6, cols=1,\n            subplot_titles=[\n                'Speed Comparison (km/h)',\n                'Throttle Position (%)',\n                'Brake Pressure',\n                'RPM',\n                'Gear',\n                'DRS Status'\n            ],\n            vertical_spacing=0.08\n        )\n        \n        # Speed comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['Speed'],\n            name=f'{driver1} Speed',\n            line=dict(color='#DC0000', width=2)\n        ), row=1, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['Speed'],\n            name=f'{driver2} Speed',\n            line=dict(color='#00D2BE', width=2)\n        ), row=1, col=1)\n        \n        # Throttle comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['Throttle'],\n            name=f'{driver1} Throttle',\n            line=dict(color='#DC0000', width=2),\n            showlegend=False\n        ), row=2, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['Throttle'],\n            name=f'{driver2} Throttle',\n            line=dict(color='#00D2BE', width=2),\n            showlegend=False\n        ), row=2, col=1)\n        \n        # Brake comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['Brake'],\n            name=f'{driver1} Brake',\n            line=dict(color='#DC0000', width=2),\n            showlegend=False\n        ), row=3, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['Brake'],\n            name=f'{driver2} Brake',\n            line=dict(color='#00D2BE', width=2),\n            showlegend=False\n        ), row=3, col=1)\n        \n        # RPM comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['RPM'],\n            name=f'{driver1} RPM',\n            line=dict(color='#DC0000', width=2),\n            showlegend=False\n        ), row=4, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['RPM'],\n            name=f'{driver2} RPM',\n            line=dict(color='#00D2BE', width=2),\n            showlegend=False\n        ), row=4, col=1)\n        \n        # Gear comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['nGear'],\n            name=f'{driver1} Gear',\n            line=dict(color='#DC0000', width=2),\n            showlegend=False,\n            mode='lines+markers',\n            marker=dict(size=3)\n        ), row=5, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['nGear'],\n            name=f'{driver2} Gear',\n            line=dict(color='#00D2BE', width=2),\n            showlegend=False,\n            mode='lines+markers',\n            marker=dict(size=3)\n        ), row=5, col=1)\n        \n        # DRS comparison\n        fig.add_trace(go.Scatter(\n            x=telemetry1['Distance'],\n            y=telemetry1['DRS'],\n            name=f'{driver1} DRS',\n            line=dict(color='#DC0000', width=2),\n            showlegend=False\n        ), row=6, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=telemetry2['Distance'],\n            y=telemetry2['DRS'],\n            name=f'{driver2} DRS',\n            line=dict(color='#00D2BE', width=2),\n            showlegend=False\n        ), row=6, col=1)\n        \n        fig.update_layout(\n            height=1200,\n            title=f'Advanced Telemetry Comparison: {driver1} vs {driver2}',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            showlegend=True\n        )\n        \n        # Update x-axis labels\n        for i in range(1, 7):\n            fig.update_xaxes(\n                title_text='Distance (m)' if i == 6 else '',\n                gridcolor='rgba(255,255,255,0.1)',\n                row=i, col=1\n            )\n            fig.update_yaxes(\n                gridcolor='rgba(255,255,255,0.1)',\n                row=i, col=1\n            )\n        \n        return fig","size_bytes":11720},"utils/brake_analysis.py":{"content":"\"\"\"\nBrake Configurations Analysis Module for F1 Data Platform\nEnhanced brake efficiency analysis based on your latest requirements\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nfrom plotly.subplots import make_subplots\nfrom utils.constants import TEAM_COLORS\n\n\nclass BrakeAnalyzer:\n    def __init__(self, session):\n        self.session = session\n        \n    def analyze_brake_efficiency(self, drivers):\n        \"\"\"Calculate enhanced brake efficiency for selected drivers\"\"\"\n        results = []\n        \n        for driver in drivers:\n            try:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                if driver_laps.empty:\n                    continue\n                    \n                fastest_lap = driver_laps.pick_fastest()\n                if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\n                    continue\n                \n                telemetry = fastest_lap.get_car_data().add_distance()\n                if telemetry.empty:\n                    continue\n                \n                # Brake and speed data\n                brake_data = telemetry['Brake']  # 1 when braking, 0 when not\n                speed_data = telemetry['Speed']\n                \n                # Enhanced brake calculation based on your requirements\n                braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\n                \n                # Total lap time in seconds\n                lap_time_seconds = fastest_lap['LapTime'].total_seconds()\n                \n                # Brake efficiency: percentage of time spent braking\n                brake_efficiency = (braking_duration / lap_time_seconds) * 100\n                \n                # Additional enhanced metrics\n                max_brake_force = brake_data.max() * 100\n                avg_brake_force = brake_data.mean() * 100\n                brake_zones = len(brake_data[brake_data > 0.1])\n                \n                # Get driver info\n                driver_info = self.session.get_driver(driver)\n                driver_name = driver_info['LastName'][:3].upper()\n                team_name = driver_info['TeamName']\n                \n                results.append({\n                    'Driver': driver_name,\n                    'Team': team_name,\n                    'Brake_Efficiency': brake_efficiency,\n                    'Max_Brake_Force': max_brake_force,\n                    'Avg_Brake_Force': avg_brake_force,\n                    'Brake_Zones': brake_zones,\n                    'Lap_Time': lap_time_seconds,\n                    'Braking_Duration': braking_duration\n                })\n                \n            except Exception as e:\n                print(f\"Error analyzing brake data for driver {driver}: {e}\")\n                continue\n        \n        return pd.DataFrame(results)\n    \n    def create_brake_efficiency_chart(self, brake_data):\n        \"\"\"Create enhanced brake efficiency visualization\"\"\"\n        if brake_data.empty:\n            return None\n        \n        # Sort by brake efficiency\n        brake_data = brake_data.sort_values('Brake_Efficiency', ascending=False)\n        \n        # Create bar chart with team colors\n        fig = go.Figure()\n        \n        colors = [TEAM_COLORS.get(team, '#FFFFFF') for team in brake_data['Team']]\n        \n        fig.add_trace(go.Bar(\n            x=brake_data['Driver'],\n            y=brake_data['Brake_Efficiency'],\n            marker_color=colors,\n            text=[f'{val:.2f}%' for val in brake_data['Brake_Efficiency']],\n            textposition='outside',\n            name='Brake Efficiency'\n        ))\n        \n        # Add mean line\n        mean_efficiency = brake_data['Brake_Efficiency'].mean()\n        fig.add_hline(y=mean_efficiency, line_dash=\"dash\", line_color=\"red\",\n                     annotation_text=f\"Mean: {mean_efficiency:.2f}%\")\n        \n        fig.update_layout(\n            title=f'Brake Efficiency Comparison - {self.session.event.year} {self.session.event[\"EventName\"]}',\n            xaxis_title='Driver',\n            yaxis_title='Brake Efficiency (%)',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            title_font=dict(size=20, color='white'),\n            showlegend=False\n        )\n        \n        fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='rgba(255,255,255,0.1)')\n        fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='rgba(255,255,255,0.1)')\n        \n        return fig\n    \n    def create_brake_efficiency_visualization(self, brake_data, session_info):\n        \"\"\"Create comprehensive brake efficiency visualization\"\"\"\n        if brake_data.empty:\n            return None\n            \n        # Sort by brake efficiency\n        brake_data_sorted = brake_data.sort_values('Brake_Efficiency', ascending=False)\n        \n        # Create subplots\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=('Brake Efficiency Comparison', 'Brake Force Analysis', \n                          'Braking Duration vs Lap Time', 'Brake Zones Distribution'),\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": True}, {\"secondary_y\": False}]]\n        )\n        \n        # 1. Brake Efficiency Bar Chart\n        colors = [TEAM_COLORS.get(team, '#808080') for team in brake_data_sorted['Team']]\n        \n        fig.add_trace(\n            go.Bar(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Brake_Efficiency'],\n                name='Brake Efficiency (%)',\n                marker_color=colors,\n                text=[f\"{eff:.1f}%\" for eff in brake_data_sorted['Brake_Efficiency']],\n                textposition='outside'\n            ),\n            row=1, col=1\n        )\n        \n        # 2. Max vs Avg Brake Force\n        fig.add_trace(\n            go.Scatter(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Max_Brake_Force'],\n                mode='lines+markers',\n                name='Max Brake Force (%)',\n                line=dict(color='#FF6B6B', width=3),\n                marker=dict(size=8)\n            ),\n            row=1, col=2\n        )\n        \n        fig.add_trace(\n            go.Scatter(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Avg_Brake_Force'],\n                mode='lines+markers',\n                name='Avg Brake Force (%)',\n                line=dict(color='#4ECDC4', width=3),\n                marker=dict(size=8)\n            ),\n            row=1, col=2\n        )\n        \n        # 3. Braking Duration vs Lap Time (with secondary y-axis)\n        fig.add_trace(\n            go.Scatter(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Braking_Duration'],\n                mode='lines+markers',\n                name='Braking Duration (s)',\n                line=dict(color='#FFD93D', width=3),\n                marker=dict(size=10)\n            ),\n            row=2, col=1\n        )\n        \n        fig.add_trace(\n            go.Scatter(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Lap_Time'],\n                mode='lines+markers',\n                name='Lap Time (s)',\n                line=dict(color='#FF8A80', width=3),\n                marker=dict(size=10),\n                yaxis='y4'\n            ),\n            row=2, col=1, secondary_y=True\n        )\n        \n        # 4. Brake Zones Distribution\n        fig.add_trace(\n            go.Bar(\n                x=brake_data_sorted['Driver'],\n                y=brake_data_sorted['Brake_Zones'],\n                name='Brake Zones',\n                marker_color='#A8E6CF',\n                text=brake_data_sorted['Brake_Zones'],\n                textposition='outside'\n            ),\n            row=2, col=2\n        )\n        \n        # Update layout\n        fig.update_layout(\n            title=f'Brake Analysis - {session_info}',\n            title_font=dict(size=20, color='white'),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            ),\n            height=800\n        )\n        \n        # Update axes\n        fig.update_xaxes(\n            gridcolor='rgba(128,128,128,0.3)',\n            title_font=dict(color='white'),\n            tickfont=dict(color='white')\n        )\n        fig.update_yaxes(\n            gridcolor='rgba(128,128,128,0.3)',\n            title_font=dict(color='white'),\n            tickfont=dict(color='white')\n        )\n        \n        # Update subplot titles\n        for annotation in fig['layout']['annotations']:\n            annotation['font'] = dict(color='white', size=14)\n        \n        return fig\n    \n    def create_brake_heatmap(self, brake_data):\n        \"\"\"Create brake performance heatmap\"\"\"\n        if brake_data.empty:\n            return None\n            \n        # Prepare data for heatmap\n        metrics = ['Brake_Efficiency', 'Max_Brake_Force', 'Avg_Brake_Force', 'Brake_Zones']\n        heatmap_data = brake_data[['Driver'] + metrics].set_index('Driver')\n        \n        # Normalize data for better visualization\n        normalized_data = (heatmap_data - heatmap_data.min()) / (heatmap_data.max() - heatmap_data.min())\n        \n        fig = go.Figure(data=go.Heatmap(\n            z=normalized_data.values.T,\n            x=normalized_data.index,\n            y=['Brake Efficiency', 'Max Brake Force', 'Avg Brake Force', 'Brake Zones'],\n            colorscale='RdYlGn',\n            colorbar=dict(title=\"Normalized Performance\", titlefont=dict(color='white')),\n            text=[[f\"{heatmap_data.iloc[j, i]:.1f}\" for j in range(len(heatmap_data))] \n                  for i in range(len(metrics))],\n            texttemplate=\"%{text}\",\n            textfont={\"size\": 10, \"color\": \"white\"},\n            hoverongaps=False\n        ))\n        \n        fig.update_layout(\n            title='Brake Performance Heatmap (Normalized)',\n            title_font=dict(size=18, color='white'),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            xaxis=dict(title='Driver', titlefont=dict(color='white')),\n            yaxis=dict(title='Metrics', titlefont=dict(color='white')),\n            height=400\n        )\n        \n        return fig","size_bytes":10712},"utils/composite_performance.py":{"content":"\"\"\"\nComposite Performance Index Module for F1 Data Platform  \nEnhanced performance calculation based on your latest specifications\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom utils.constants import TEAM_COLORS\n\n\nclass CompositePerformanceAnalyzer:\n    def __init__(self, session):\n        self.session = session\n        \n    def calculate_composite_performance(self, drivers):\n        \"\"\"Calculate enhanced composite performance index for selected drivers\"\"\"\n        results = []\n        \n        for driver in drivers:\n            try:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                if driver_laps.empty:\n                    continue\n                    \n                fastest_lap = driver_laps.pick_fastest()\n                if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\n                    continue\n                \n                telemetry = fastest_lap.get_car_data().add_distance()\n                if telemetry.empty:\n                    continue\n                \n                # Speed, acceleration and brake data\n                brake_data = telemetry['Brake']  # 1 when braking, 0 when not\n                speed_data = telemetry['Speed']\n                acceleration_data = speed_data.diff() / telemetry['Distance'].diff()  # Basic acceleration calculation\n                \n                # Enhanced brake calculation based on your requirements\n                braking_duration = brake_data.sum() * (telemetry['Distance'].diff().mean() / speed_data.mean())\n                \n                # Total lap time in seconds\n                lap_time_seconds = fastest_lap['LapTime'].total_seconds()\n                \n                # Brake efficiency: percentage of time spent braking\n                brake_efficiency = (braking_duration / lap_time_seconds) * 100\n                \n                # Speed factor\n                speed_factor = speed_data.mean()\n                \n                # Acceleration factor\n                acceleration_factor = acceleration_data[acceleration_data > 0].mean()  # Acceleration (positive changes in speed)\n                \n                # Handle NaN values\n                if pd.isna(acceleration_factor):\n                    acceleration_factor = 0.1\n                \n                # Handling time (time spent at speeds lower than threshold, indicating cornering)\n                handling_threshold = speed_data.mean() * 0.7  # Assuming cornering happens at 70% of average speed\n                handling_time = len(speed_data[speed_data < handling_threshold]) * (telemetry['Distance'].diff().mean() / speed_data.mean())\n                \n                # Composite Performance Index\n                denominator = max(brake_efficiency + handling_time, 1)  # Avoid division by zero\n                composite_performance_index = (speed_factor * acceleration_factor) / denominator\n                \n                # Get driver info\n                driver_info = self.session.get_driver(driver)\n                driver_name = driver_info['LastName'][:3].upper()\n                team_name = driver_info['TeamName']\n                \n                results.append({\n                    'Driver': driver_name,\n                    'Team': team_name,\n                    'Composite_Performance_Index': composite_performance_index,\n                    'Speed_Factor': speed_factor,\n                    'Acceleration_Factor': acceleration_factor,\n                    'Brake_Efficiency': brake_efficiency,\n                    'Handling_Time': handling_time,\n                    'Lap_Time': lap_time_seconds\n                })\n                \n            except Exception as e:\n                print(f\"Error calculating composite performance for driver {driver}: {e}\")\n                continue\n        \n        return pd.DataFrame(results)\n    \n    def create_composite_performance_chart(self, performance_data):\n        \"\"\"Create enhanced composite performance visualization\"\"\"\n        if performance_data.empty:\n            return None\n        \n        # Sort by composite performance index\n        performance_data = performance_data.sort_values('Composite_Performance_Index', ascending=False)\n        \n        # Create bar chart with team colors\n        fig = go.Figure()\n        \n        colors = [TEAM_COLORS.get(team, '#FFFFFF') for team in performance_data['Team']]\n        \n        fig.add_trace(go.Bar(\n            x=performance_data['Driver'],\n            y=performance_data['Composite_Performance_Index'],\n            marker_color=colors,\n            text=[f'{val:.2f}' for val in performance_data['Composite_Performance_Index']],\n            textposition='outside',\n            name='Composite Performance Index'\n        ))\n        \n        # Add mean line\n        mean_performance = performance_data['Composite_Performance_Index'].mean()\n        fig.add_hline(y=mean_performance, line_dash=\"dash\", line_color=\"red\",\n                     annotation_text=f\"Mean: {mean_performance:.2f}\")\n        \n        fig.update_layout(\n            title=f'Composite Performance Index - {self.session.event.year} {self.session.event[\"EventName\"]}',\n            xaxis_title='Driver',\n            yaxis_title='Composite Performance Index',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            title_font=dict(size=20, color='white'),\n            showlegend=False,\n            annotations=[\n                dict(\n                    text=\"Formula: (Speed Factor × Acceleration Factor) ÷ (Brake Efficiency + Handling Time)\",\n                    showarrow=False,\n                    xref=\"paper\", yref=\"paper\",\n                    x=0.5, y=-0.1, xanchor='center', yanchor='top',\n                    font=dict(size=12, color='white')\n                )\n            ]\n        )\n        \n        fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='rgba(255,255,255,0.1)')\n        fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='rgba(255,255,255,0.1)')\n        \n        return fig\n    \n    def create_composite_performance_visualization(self, performance_data, session_info):\n        \"\"\"Create comprehensive composite performance visualization\"\"\"\n        if performance_data.empty:\n            return None\n            \n        # Sort by composite performance index\n        perf_data_sorted = performance_data.sort_values('Composite_Performance_Index', ascending=False)\n        \n        # Create subplots\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=('Composite Performance Index', 'Performance Factors Breakdown', \n                          'Speed vs Acceleration Analysis', 'Efficiency Metrics'),\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n        )\n        \n        # 1. Composite Performance Index Bar Chart\n        colors = [TEAM_COLORS.get(team, '#808080') for team in perf_data_sorted['Team']]\n        \n        fig.add_trace(\n            go.Bar(\n                x=perf_data_sorted['Driver'],\n                y=perf_data_sorted['Composite_Performance_Index'],\n                name='Composite Performance Index',\n                marker_color=colors,\n                text=[f\"{cpi:.2f}\" for cpi in perf_data_sorted['Composite_Performance_Index']],\n                textposition='outside'\n            ),\n            row=1, col=1\n        )\n        \n        # Add average line\n        mean_performance = perf_data_sorted['Composite_Performance_Index'].mean()\n        fig.add_hline(\n            y=mean_performance,\n            line_dash=\"dash\",\n            line_color=\"red\",\n            annotation_text=f\"Average: {mean_performance:.2f}\",\n            row=1, col=1\n        )\n        \n        # 2. Performance Factors Breakdown (Stacked Bar)\n        fig.add_trace(\n            go.Bar(\n                x=perf_data_sorted['Driver'],\n                y=perf_data_sorted['Speed_Factor'],\n                name='Speed Factor',\n                marker_color='#FF6B6B'\n            ),\n            row=1, col=2\n        )\n        \n        fig.add_trace(\n            go.Bar(\n                x=perf_data_sorted['Driver'],\n                y=perf_data_sorted['Acceleration_Factor'] * 100,  # Scale for visibility\n                name='Acceleration Factor (x100)',\n                marker_color='#4ECDC4'\n            ),\n            row=1, col=2\n        )\n        \n        # 3. Speed vs Acceleration Scatter\n        fig.add_trace(\n            go.Scatter(\n                x=perf_data_sorted['Speed_Factor'],\n                y=perf_data_sorted['Acceleration_Factor'],\n                mode='markers+text',\n                name='Speed vs Acceleration',\n                marker=dict(\n                    size=15,\n                    color=[TEAM_COLORS.get(team, '#808080') for team in perf_data_sorted['Team']],\n                    line=dict(width=2, color='white')\n                ),\n                text=perf_data_sorted['Driver'],\n                textposition=\"top center\",\n                textfont=dict(color='white', size=10)\n            ),\n            row=2, col=1\n        )\n        \n        # 4. Efficiency Metrics\n        fig.add_trace(\n            go.Scatter(\n                x=perf_data_sorted['Driver'],\n                y=perf_data_sorted['Speed_Consistency'] * 100,\n                mode='lines+markers',\n                name='Speed Consistency (%)',\n                line=dict(color='#FFD93D', width=3),\n                marker=dict(size=8)\n            ),\n            row=2, col=2\n        )\n        \n        fig.add_trace(\n            go.Scatter(\n                x=perf_data_sorted['Driver'],\n                y=perf_data_sorted['Throttle_Efficiency'],\n                mode='lines+markers',\n                name='Throttle Efficiency (%)',\n                line=dict(color='#FF8A80', width=3),\n                marker=dict(size=8)\n            ),\n            row=2, col=2\n        )\n        \n        # Update layout\n        fig.update_layout(\n            title=f'Composite Performance Analysis - {session_info}',\n            title_font=dict(size=20, color='white'),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            ),\n            height=800\n        )\n        \n        # Update axes\n        fig.update_xaxes(\n            gridcolor='rgba(128,128,128,0.3)',\n            title_font=dict(color='white'),\n            tickfont=dict(color='white')\n        )\n        fig.update_yaxes(\n            gridcolor='rgba(128,128,128,0.3)',\n            title_font=dict(color='white'),\n            tickfont=dict(color='white')\n        )\n        \n        # Update subplot titles\n        for annotation in fig['layout']['annotations']:\n            annotation['font'] = dict(color='white', size=14)\n        \n        return fig\n    \n    def create_performance_radar(self, performance_data):\n        \"\"\"Create radar chart for performance comparison\"\"\"\n        if performance_data.empty or len(performance_data) == 0:\n            return None\n        \n        # Normalize metrics for radar chart\n        metrics = ['Speed_Factor', 'Acceleration_Factor', 'Speed_Consistency', \n                  'Throttle_Efficiency', 'Composite_Performance_Index']\n        \n        normalized_data = performance_data.copy()\n        for metric in metrics:\n            if metric in normalized_data.columns:\n                min_val = normalized_data[metric].min()\n                max_val = normalized_data[metric].max()\n                if max_val != min_val:\n                    normalized_data[metric] = (normalized_data[metric] - min_val) / (max_val - min_val)\n                else:\n                    normalized_data[metric] = 0.5\n        \n        fig = go.Figure()\n        \n        # Add trace for each driver (limit to top 5 for readability)\n        top_drivers = performance_data.nlargest(5, 'Composite_Performance_Index')\n        \n        for _, driver_data in top_drivers.iterrows():\n            values = []\n            for metric in metrics:\n                norm_val = normalized_data[normalized_data['Driver'] == driver_data['Driver']][metric].iloc[0]\n                values.append(norm_val)\n            \n            values.append(values[0])  # Close the radar chart\n            \n            fig.add_trace(go.Scatterpolar(\n                r=values,\n                theta=metrics + [metrics[0]],\n                fill='toself',\n                name=driver_data['Driver'],\n                line_color=TEAM_COLORS.get(driver_data['Team'], '#808080')\n            ))\n        \n        fig.update_layout(\n            polar=dict(\n                radialaxis=dict(\n                    visible=True,\n                    range=[0, 1],\n                    gridcolor='rgba(128,128,128,0.3)',\n                    tickfont=dict(color='white')\n                ),\n                angularaxis=dict(\n                    gridcolor='rgba(128,128,128,0.3)',\n                    tickfont=dict(color='white')\n                )\n            ),\n            title='Performance Radar Comparison (Top 5 Drivers)',\n            title_font=dict(size=18, color='white'),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            height=500\n        )\n        \n        return fig","size_bytes":13660},"utils/constants.py":{"content":"\"\"\"\nConstants for F1 data analysis platform\n\"\"\"\n\n# Team colors (2024 season)\nTEAM_COLORS = {\n    'Mercedes': '#00D2BE',\n    'Red Bull Racing': '#1E41FF',\n    'Ferrari': '#DC0000',\n    'McLaren': '#FF8700',\n    'Alpine': '#0090FF',\n    'Aston Martin': '#006F62',\n    'Haas': '#808080',\n    'RB': '#1660AD',\n    'Williams': '#87CEEB',\n    'Kick Sauber': '#00E701'\n}\n\n# Driver team mappings (2024 season)\nDRIVER_TEAMS = {\n    'VER': 'Red Bull Racing',\n    'PER': 'Red Bull Racing',\n    'LEC': 'Ferrari',\n    'SAI': 'Ferrari',\n    'HAM': 'Mercedes',\n    'RUS': 'Mercedes',\n    'NOR': 'McLaren',\n    'PIA': 'McLaren',\n    'ALO': 'Aston Martin',\n    'STR': 'Aston Martin',\n    'GAS': 'Alpine',\n    'OCO': 'Alpine',\n    'MAG': 'Haas',\n    'HUL': 'Haas',\n    'TSU': 'RB',\n    'RIC': 'RB',\n    'ALB': 'Williams',\n    'SAR': 'Williams',\n    'ZHO': 'Kick Sauber',\n    'BOT': 'Kick Sauber'\n}\n\n# Grand Prix list\nGRANDS_PRIX = [\n    'Australian Grand Prix',\n    'Chinese Grand Prix', \n    'Japanese Grand Prix',\n    'Bahrain Grand Prix',\n    'Saudi Arabian Grand Prix',\n    'Miami Grand Prix',\n    'Emilia Romagna Grand Prix',\n    'Monaco Grand Prix',\n    'Spanish Grand Prix',\n    'Canadian Grand Prix',\n    'Austrian Grand Prix',\n    'British Grand Prix',\n    'Belgian Grand Prix',\n    'Hungarian Grand Prix',\n    'Dutch Grand Prix',\n    'Italian Grand Prix',\n    'Azerbaijan Grand Prix',\n    'Singapore Grand Prix',\n    'United States Grand Prix',\n    'Mexico City Grand Prix',\n    'São Paulo Grand Prix',\n    'Las Vegas Grand Prix',\n    'Qatar Grand Prix',\n    'Abu Dhabi Grand Prix'\n]\n\n# Session types\nSESSIONS = {\n    'Practice 1': 'FP1',\n    'Practice 2': 'FP2', \n    'Practice 3': 'FP3',\n    'Qualifying': 'Q',\n    'Sprint': 'Sprint',\n    'Sprint Qualifying': 'SQ',\n    'Race': 'R'\n}\n\n# Tire compound colors\nTIRE_COLORS = {\n    'SOFT': '#DC0000',\n    'MEDIUM': '#FFD700',\n    'HARD': '#FFFFFF',\n    'INTERMEDIATE': '#00FF00',\n    'WET': '#0000FF'\n}\n\n# Circuit aliases for better display names\nCIRCUIT_ALIASES = {\n    'Albert Park Grand Prix Circuit': 'Albert Park',\n    'Bahrain International Circuit': 'Bahrain',\n    'Jeddah Corniche Circuit': 'Jeddah',\n    'Suzuka Circuit': 'Suzuka',\n    'Shanghai International Circuit': 'Shanghai',\n    'Miami International Autodrome': 'Miami',\n    'Autodromo Enzo e Dino Ferrari': 'Imola',\n    'Circuit de Monaco': 'Monaco',\n    'Circuit de Barcelona-Catalunya': 'Barcelona',\n    'Circuit Gilles Villeneuve': 'Montreal',\n    'Red Bull Ring': 'Spielberg',\n    'Silverstone Circuit': 'Silverstone',\n    'Hungaroring': 'Budapest',\n    'Circuit de Spa-Francorchamps': 'Spa',\n    'Circuit Zandvoort': 'Zandvoort',\n    'Autodromo Nazionale di Monza': 'Monza',\n    'Baku City Circuit': 'Baku',\n    'Marina Bay Street Circuit': 'Singapore',\n    'Circuit of the Americas': 'Austin',\n    'Autódromo Hermanos Rodríguez': 'Mexico City',\n    'Autódromo José Carlos Pace': 'Interlagos',\n    'Las Vegas Strip Street Circuit': 'Las Vegas',\n    'Losail International Circuit': 'Losail',\n    'Yas Marina Circuit': 'Abu Dhabi'\n}\n","size_bytes":3048},"utils/data_loader.py":{"content":"\"\"\"\nData loading utilities for F1 analysis platform\n\"\"\"\n\nimport fastf1\nimport pandas as pd\nimport numpy as np\nimport os\nimport tempfile\nfrom datetime import datetime\nimport streamlit as st\nfrom .constants import DRIVER_TEAMS, CIRCUIT_ALIASES\n\nclass DataLoader:\n    def __init__(self):\n        self.session = None\n        self.session_info = {}\n        self._setup_cache()\n        \n    def _setup_cache(self):\n        \"\"\"Setup FastF1 caching\"\"\"\n        try:\n            # Use system temp directory for cache\n            cache_dir = os.path.join(tempfile.gettempdir(), 'fastf1_cache')\n            os.makedirs(cache_dir, exist_ok=True)\n            fastf1.Cache.enable_cache(cache_dir)\n        except Exception as e:\n            st.warning(f\"Could not setup cache: {e}\")\n    \n    def load_session(self, year, grand_prix, session_type):\n        \"\"\"Load F1 session data\"\"\"\n        try:\n            self.session = fastf1.get_session(year, grand_prix, session_type)\n            self.session.load()\n            \n            # Store session info\n            self.session_info = {\n                'year': year,\n                'event_name': grand_prix,\n                'session_name': session_type,\n                'date': self.session.date.strftime('%Y-%m-%d') if hasattr(self.session, 'date') and self.session.date else 'Unknown',\n                'circuit': CIRCUIT_ALIASES.get(self.session.event['EventName'], self.session.event['EventName']) if hasattr(self.session, 'event') else 'Unknown'\n            }\n            \n            return True\n            \n        except Exception as e:\n            st.error(f\"Failed to load session: {str(e)}\")\n            return False\n    \n    def get_session_info(self):\n        \"\"\"Get current session information\"\"\"\n        return self.session_info if hasattr(self, 'session_info') else None\n    \n    def get_available_drivers(self):\n        \"\"\"Get list of available drivers in current session\"\"\"\n        if self.session is None:\n            return []\n        \n        try:\n            if hasattr(self.session, 'results') and not self.session.results.empty:\n                return sorted(self.session.results['Abbreviation'].tolist())\n            elif hasattr(self.session, 'laps') and not self.session.laps.empty:\n                return sorted(self.session.laps['Driver'].unique().tolist())\n            else:\n                return []\n        except Exception as e:\n            st.error(f\"Error getting drivers: {str(e)}\")\n            return []\n    \n    def get_driver_telemetry(self, driver, lap_type='fastest'):\n        \"\"\"Get telemetry data for a specific driver\"\"\"\n        if self.session is None:\n            return None\n        \n        try:\n            driver_laps = self.session.laps.pick_drivers(driver)\n            if driver_laps.empty:\n                return None\n            \n            if lap_type == 'fastest':\n                lap = driver_laps.pick_fastest()\n            else:\n                lap = driver_laps.iloc[0]  # First lap as default\n            \n            if lap is None or pd.isna(lap.name):\n                return None\n                \n            telemetry = lap.get_telemetry()\n            return telemetry\n            \n        except Exception as e:\n            st.error(f\"Error getting telemetry for {driver}: {str(e)}\")\n            return None\n    \n    def get_lap_comparison(self, drivers):\n        \"\"\"Get lap time comparison data for selected drivers\"\"\"\n        if self.session is None:\n            return None\n        \n        try:\n            lap_data = []\n            \n            for driver in drivers:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                if driver_laps.empty:\n                    continue\n                    \n                for _, lap in driver_laps.iterrows():\n                    if pd.notna(lap['LapTime']) and lap['LapTime'].total_seconds() > 0:\n                        lap_data.append({\n                            'Driver': driver,\n                            'LapNumber': lap['LapNumber'],\n                            'LapTime': str(lap['LapTime']).split('.')[0],  # Remove microseconds\n                            'LapTime_seconds': lap['LapTime'].total_seconds(),\n                            'Compound': lap.get('Compound', 'Unknown'),\n                            'TyreLife': lap.get('TyreLife', 0),\n                            'Sector1Time': lap.get('Sector1Time', pd.NaT),\n                            'Sector2Time': lap.get('Sector2Time', pd.NaT),\n                            'Sector3Time': lap.get('Sector3Time', pd.NaT)\n                        })\n            \n            if lap_data:\n                return pd.DataFrame(lap_data)\n            else:\n                return pd.DataFrame()\n                \n        except Exception as e:\n            st.error(f\"Error getting lap comparison: {str(e)}\")\n            return None\n    \n    def get_tire_data(self, drivers):\n        \"\"\"Get tire strategy data for selected drivers\"\"\"\n        if self.session is None:\n            return None\n        \n        try:\n            tire_data = []\n            \n            for driver in drivers:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                if driver_laps.empty:\n                    continue\n                    \n                for _, lap in driver_laps.iterrows():\n                    if pd.notna(lap['LapTime']):\n                        tire_data.append({\n                            'Driver': driver,\n                            'LapNumber': lap['LapNumber'],\n                            'Compound': lap.get('Compound', 'Unknown'),\n                            'TyreLife': lap.get('TyreLife', 0),\n                            'LapTime_seconds': lap['LapTime'].total_seconds() if pd.notna(lap['LapTime']) else None\n                        })\n            \n            if tire_data:\n                return pd.DataFrame(tire_data)\n            else:\n                return pd.DataFrame()\n                \n        except Exception as e:\n            st.error(f\"Error getting tire data: {str(e)}\")\n            return None\n    \n    def get_position_data(self, drivers):\n        \"\"\"Get position data for race progression analysis\"\"\"\n        if self.session is None:\n            return None\n        \n        try:\n            position_data = []\n            \n            for driver in drivers:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                if driver_laps.empty:\n                    continue\n                    \n                for _, lap in driver_laps.iterrows():\n                    if pd.notna(lap.get('Position')):\n                        position_data.append({\n                            'Driver': driver,\n                            'LapNumber': lap['LapNumber'],\n                            'Position': lap['Position'],\n                            'LapTime_seconds': lap['LapTime'].total_seconds() if pd.notna(lap['LapTime']) else None\n                        })\n            \n            if position_data:\n                return pd.DataFrame(position_data)\n            else:\n                return pd.DataFrame()\n                \n        except Exception as e:\n            st.error(f\"Error getting position data: {str(e)}\")\n            return None\n    \n    def get_fastest_lap_telemetry(self, drivers):\n        \"\"\"Get fastest lap telemetry for multiple drivers\"\"\"\n        if self.session is None:\n            return {}\n        \n        telemetry_data = {}\n        \n        for driver in drivers:\n            telemetry = self.get_driver_telemetry(driver, 'fastest')\n            if telemetry is not None and not telemetry.empty:\n                telemetry_data[driver] = telemetry\n        \n        return telemetry_data\n    \n    def get_session_results(self):\n        \"\"\"Get session results if available\"\"\"\n        if self.session is None:\n            return None\n            \n        try:\n            if hasattr(self.session, 'results') and not self.session.results.empty:\n                return self.session.results\n            else:\n                return None\n        except Exception as e:\n            st.error(f\"Error getting session results: {str(e)}\")\n            return None\n","size_bytes":8176},"utils/downforce_analysis.py":{"content":"\"\"\"\nDownforce Configuration Analysis Module\nAdvanced aerodynamic performance analysis for F1 data\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom utils.constants import TEAM_COLORS\n\n\nclass DownforceAnalyzer:\n    \"\"\"Advanced downforce and aerodynamic analysis for F1 performance\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        \n    def calculate_downforce_metrics(self):\n        \"\"\"Calculate comprehensive downforce and aerodynamic metrics\"\"\"\n        drivers = self.session.drivers\n        results = []\n\n        for driver in drivers:\n            try:\n                driver_laps = self.session.laps.pick_drivers(driver)\n                fastest_lap = driver_laps.pick_fastest()\n                \n                if fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\n                    continue\n                \n                telemetry = fastest_lap.get_car_data().add_distance()\n                \n                speed_data = telemetry['Speed']\n                average_speed = speed_data.mean()\n                top_speed = speed_data.max()\n                \n                # Downforce efficiency ratio\n                downforce_efficiency = 100 * (average_speed / top_speed)\n                \n                # Speed variance for cornering analysis\n                speed_variance = speed_data.std()\n                \n                # Corner speed analysis (speeds below 80% of max)\n                corner_threshold = top_speed * 0.8\n                corner_speeds = speed_data[speed_data < corner_threshold]\n                avg_corner_speed = corner_speeds.mean() if len(corner_speeds) > 0 else 0\n                \n                # Straight line speed analysis (speeds above 90% of max)\n                straight_threshold = top_speed * 0.9\n                straight_speeds = speed_data[speed_data > straight_threshold]\n                avg_straight_speed = straight_speeds.mean() if len(straight_speeds) > 0 else top_speed\n                \n                # Aerodynamic balance indicator\n                aero_balance = (avg_corner_speed / avg_straight_speed) * 100 if avg_straight_speed > 0 else 0\n                \n                driver_info = self.session.get_driver(driver)\n                driver_name = driver_info['LastName'][:3].upper()\n                team_name = driver_info.get('TeamName', 'Unknown')\n                \n                results.append({\n                    'Driver': driver_name,\n                    'Team': team_name,\n                    'Average_Speed': average_speed,\n                    'Top_Speed': top_speed,\n                    'Downforce_Efficiency': downforce_efficiency,\n                    'Speed_Variance': speed_variance,\n                    'Corner_Speed_Avg': avg_corner_speed,\n                    'Straight_Speed_Avg': avg_straight_speed,\n                    'Aero_Balance': aero_balance,\n                    'Speed_Range': top_speed - speed_data.min()\n                })\n                \n            except Exception as e:\n                continue\n                \n        return pd.DataFrame(results)\n\n    def create_downforce_visualizations(self, df_downforce, session_info):\n        \"\"\"Create comprehensive downforce analysis visualizations\"\"\"\n        \n        if df_downforce.empty:\n            return None\n            \n        # Create subplot layout\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=[\n                'Downforce Efficiency by Driver',\n                'Aerodynamic Balance Analysis',\n                'Speed Profile Comparison',\n                'Corner vs Straight Speed Performance'\n            ],\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n        )\n\n        # Sort by downforce efficiency\n        df_sorted = df_downforce.sort_values('Downforce_Efficiency', ascending=False)\n        \n        # Get team colors\n        colors = [TEAM_COLORS.get(team, '#888888') for team in df_sorted['Team']]\n\n        # 1. Downforce Efficiency Bar Chart\n        fig.add_trace(\n            go.Bar(\n                x=df_sorted['Driver'],\n                y=df_sorted['Downforce_Efficiency'],\n                name='Downforce Efficiency',\n                marker_color=colors,\n                text=[f\"{val:.2f}%\" for val in df_sorted['Downforce_Efficiency']],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Efficiency: %{y:.2f}%<br>' +\n                             'Avg Speed: %{customdata[0]:.1f} km/h<br>' +\n                             'Top Speed: %{customdata[1]:.1f} km/h<extra></extra>',\n                customdata=list(zip(df_sorted['Average_Speed'], df_sorted['Top_Speed']))\n            ),\n            row=1, col=1\n        )\n\n        # Add mean line for downforce efficiency\n        mean_efficiency = df_sorted['Downforce_Efficiency'].mean()\n        fig.add_hline(\n            y=mean_efficiency,\n            line_dash=\"dash\",\n            line_color=\"red\",\n            annotation_text=f\"Mean: {mean_efficiency:.2f}%\",\n            row=1, col=1\n        )\n\n        # 2. Aerodynamic Balance Scatter Plot\n        fig.add_trace(\n            go.Scatter(\n                x=df_downforce['Corner_Speed_Avg'],\n                y=df_downforce['Straight_Speed_Avg'],\n                mode='markers+text',\n                text=df_downforce['Driver'],\n                textposition='top center',\n                marker=dict(\n                    size=df_downforce['Aero_Balance'] * 0.5,\n                    color=[TEAM_COLORS.get(team, '#888888') for team in df_downforce['Team']],\n                    line=dict(width=2, color='white'),\n                    opacity=0.8\n                ),\n                name='Aero Balance',\n                hovertemplate='<b>%{text}</b><br>' +\n                             'Corner Speed: %{x:.1f} km/h<br>' +\n                             'Straight Speed: %{y:.1f} km/h<br>' +\n                             'Aero Balance: %{marker.size:.1f}%<extra></extra>'\n            ),\n            row=1, col=2\n        )\n\n        # 3. Speed Profile Comparison\n        fig.add_trace(\n            go.Bar(\n                x=df_downforce['Driver'],\n                y=df_downforce['Speed_Variance'],\n                name='Speed Variance',\n                marker=dict(\n                    color=df_downforce['Speed_Variance'],\n                    colorscale='Viridis',\n                    showscale=False,\n                    line=dict(width=1, color='white')\n                ),\n                text=[f\"{val:.1f}\" for val in df_downforce['Speed_Variance']],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Speed Variance: %{y:.2f} km/h<extra></extra>'\n            ),\n            row=2, col=1\n        )\n\n        # 4. Corner vs Straight Speed Analysis\n        fig.add_trace(\n            go.Scatter(\n                x=df_downforce['Driver'],\n                y=df_downforce['Corner_Speed_Avg'],\n                mode='markers+lines',\n                name='Corner Speed',\n                marker=dict(size=10, color='#FF6B6B'),\n                line=dict(color='#FF6B6B', width=3),\n                yaxis='y4'\n            ),\n            row=2, col=2\n        )\n        \n        fig.add_trace(\n            go.Scatter(\n                x=df_downforce['Driver'],\n                y=df_downforce['Straight_Speed_Avg'],\n                mode='markers+lines',\n                name='Straight Speed',\n                marker=dict(size=10, color='#4ECDC4'),\n                line=dict(color='#4ECDC4', width=3),\n                yaxis='y4'\n            ),\n            row=2, col=2\n        )\n\n        # Update layout\n        fig.update_layout(\n            title=dict(\n                text=f\"<b>Downforce & Aerodynamic Analysis - {session_info}</b>\",\n                x=0.5,\n                font=dict(size=24, color='white', family='Inter')\n            ),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            showlegend=True,\n            height=900,\n            margin=dict(t=100, b=50, l=50, r=50)\n        )\n\n        # Update axes styling\n        for i in range(1, 3):\n            for j in range(1, 3):\n                fig.update_xaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    tickangle=45,\n                    row=i, col=j\n                )\n                fig.update_yaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    row=i, col=j\n                )\n\n        return fig\n\n    def create_downforce_ranking_chart(self, df_downforce):\n        \"\"\"Create professional downforce efficiency ranking\"\"\"\n        \n        if df_downforce.empty:\n            return None\n            \n        df_sorted = df_downforce.sort_values('Downforce_Efficiency', ascending=False)\n        \n        fig = go.Figure()\n\n        # Add bars with team colors\n        colors = [TEAM_COLORS.get(team, '#888888') for team in df_sorted['Team']]\n        \n        fig.add_trace(go.Bar(\n            x=df_sorted['Driver'],\n            y=df_sorted['Downforce_Efficiency'],\n            marker_color=colors,\n            text=[f\"{val:.2f}%\" for val in df_sorted['Downforce_Efficiency']],\n            textposition='outside',\n            textfont=dict(color='white', size=12),\n            hovertemplate='<b>%{x}</b><br>' +\n                         'Downforce Efficiency: %{y:.2f}%<br>' +\n                         'Team: %{customdata}<extra></extra>',\n            customdata=df_sorted['Team']\n        ))\n\n        # Add mean line\n        mean_efficiency = df_sorted['Downforce_Efficiency'].mean()\n        fig.add_hline(\n            y=mean_efficiency,\n            line_dash=\"dash\",\n            line_color=\"red\",\n            annotation_text=f\"Mean: {mean_efficiency:.2f}%\",\n            annotation_position=\"top right\",\n            annotation_font_color=\"white\"\n        )\n\n        fig.update_layout(\n            title=dict(\n                text=\"<b>Downforce Efficiency Ranking</b>\",\n                x=0.5,\n                font=dict(size=22, color='white', family='Inter')\n            ),\n            xaxis=dict(\n                title='Driver',\n                color='white',\n                tickangle=45,\n                gridcolor='rgba(128, 128, 128, 0.2)'\n            ),\n            yaxis=dict(\n                title='Downforce Efficiency (%)',\n                color='white',\n                gridcolor='rgba(128, 128, 128, 0.2)'\n            ),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            height=600,\n            margin=dict(t=80, b=100, l=50, r=50)\n        )\n\n        return fig","size_bytes":11058},"utils/driver_manager.py":{"content":"\"\"\"\nDynamic Driver Management Module\nFetches current driver-team mappings from FastF1 session data\n\"\"\"\n\nimport pandas as pd\n\n\nclass DynamicDriverManager:\n    \"\"\"Manages driver information dynamically from session data\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        self._driver_info = None\n        self._team_mappings = None\n        \n    def get_driver_info(self):\n        \"\"\"Get comprehensive driver information from session\"\"\"\n        if self._driver_info is None:\n            self._driver_info = {}\n            \n            try:\n                # Get driver info from session\n                drivers = self.session.drivers\n                \n                for driver_code in drivers:\n                    driver_data = self.session.get_driver(driver_code)\n                    \n                    if driver_data is not None:\n                        self._driver_info[driver_code] = {\n                            'full_name': f\"{driver_data.get('FirstName', '')} {driver_data.get('LastName', '')}\".strip(),\n                            'abbreviation': driver_data.get('Abbreviation', driver_code),\n                            'team_name': driver_data.get('TeamName', 'Unknown'),\n                            'team_color': driver_data.get('TeamColor', '#808080'),\n                            'driver_number': driver_data.get('DriverNumber', ''),\n                            'country_code': driver_data.get('CountryCode', ''),\n                            'broadcast_name': driver_data.get('BroadcastName', driver_code)\n                        }\n                        \n            except Exception as e:\n                print(f\"Error fetching driver info: {e}\")\n                \n        return self._driver_info\n    \n    def get_team_mappings(self):\n        \"\"\"Get current driver-team mappings for this session\"\"\"\n        if self._team_mappings is None:\n            driver_info = self.get_driver_info()\n            self._team_mappings = {}\n            \n            for driver_code, info in driver_info.items():\n                self._team_mappings[driver_code] = info['team_name']\n                \n        return self._team_mappings\n    \n    def get_team_colors(self):\n        \"\"\"Get team colors from session data\"\"\"\n        driver_info = self.get_driver_info()\n        team_colors = {}\n        \n        for driver_code, info in driver_info.items():\n            team_name = info['team_name']\n            if team_name not in team_colors:\n                # Convert hex color if it starts with #\n                color = info['team_color']\n                if color and not color.startswith('#'):\n                    color = f\"#{color}\"\n                team_colors[team_name] = color or '#808080'\n                \n        return team_colors\n    \n    def get_driver_display_names(self):\n        \"\"\"Get formatted driver names for display\"\"\"\n        driver_info = self.get_driver_info()\n        display_names = {}\n        \n        for driver_code, info in driver_info.items():\n            # Use abbreviation if available, otherwise use the driver code\n            display_name = info.get('abbreviation', driver_code)\n            display_names[driver_code] = display_name\n            \n        return display_names\n    \n    def get_drivers_by_team(self):\n        \"\"\"Group drivers by their teams\"\"\"\n        driver_info = self.get_driver_info()\n        teams = {}\n        \n        for driver_code, info in driver_info.items():\n            team_name = info['team_name']\n            if team_name not in teams:\n                teams[team_name] = []\n            teams[team_name].append({\n                'code': driver_code,\n                'name': info.get('abbreviation', driver_code),\n                'full_name': info.get('full_name', driver_code),\n                'number': info.get('driver_number', '')\n            })\n            \n        return teams","size_bytes":3871},"utils/enhanced_analytics.py":{"content":"\"\"\"\nEnhanced Advanced Analytics Module\nProvides cutting-edge F1 performance analysis with machine learning insights\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom scipy import stats\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport plotly.express as px\nfrom utils.constants import TEAM_COLORS\n\n\nclass EnhancedF1Analytics:\n    \"\"\"Advanced F1 analytics with machine learning and statistical analysis\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        self.laps = session.laps\n        self.results = session.results\n        \n    def calculate_driver_performance_index(self, drivers):\n        \"\"\"Calculate comprehensive performance index using multiple metrics\"\"\"\n        performance_data = []\n        \n        for driver in drivers:\n            try:\n                driver_laps = self.laps.pick_drivers(driver)\n                valid_laps = driver_laps[driver_laps['LapTime'].notna()]\n                \n                if len(valid_laps) < 3:\n                    continue\n                \n                lap_times = valid_laps['LapTime'].dt.total_seconds()\n                \n                # Performance metrics\n                consistency_score = 1 / (1 + lap_times.std())\n                speed_consistency = 1 / (1 + valid_laps['SpeedI1'].std() / valid_laps['SpeedI1'].mean())\n                pace_quality = 1 / lap_times.mean() * 100\n                \n                # Racecraft analysis\n                overtakes = self._analyze_overtakes(valid_laps)\n                sector_dominance = self._calculate_sector_dominance(valid_laps)\n                \n                # Tire management\n                tire_efficiency = self._calculate_tire_efficiency(valid_laps)\n                \n                # Overall performance index (weighted combination)\n                performance_index = (\n                    consistency_score * 0.25 +\n                    speed_consistency * 0.20 +\n                    pace_quality * 0.25 +\n                    overtakes * 0.10 +\n                    sector_dominance * 0.10 +\n                    tire_efficiency * 0.10\n                )\n                \n                driver_info = self.session.get_driver(driver)\n                \n                performance_data.append({\n                    'Driver': driver_info.get('Abbreviation', driver),\n                    'Team': driver_info.get('TeamName', 'Unknown'),\n                    'Performance_Index': performance_index,\n                    'Consistency_Score': consistency_score,\n                    'Speed_Consistency': speed_consistency,\n                    'Pace_Quality': pace_quality,\n                    'Overtake_Score': overtakes,\n                    'Sector_Dominance': sector_dominance,\n                    'Tire_Efficiency': tire_efficiency,\n                    'Total_Laps': len(valid_laps),\n                    'Best_Lap': lap_times.min(),\n                    'Average_Lap': lap_times.mean()\n                })\n                \n            except Exception as e:\n                continue\n                \n        return pd.DataFrame(performance_data)\n    \n    def _analyze_overtakes(self, laps):\n        \"\"\"Analyze overtaking performance\"\"\"\n        try:\n            positions = laps['Position'].dropna()\n            if len(positions) < 2:\n                return 0\n            \n            position_changes = positions.diff()\n            overtakes = len(position_changes[position_changes < 0])  # Negative = gained positions\n            return min(1.0, overtakes / len(positions))\n        except:\n            return 0\n    \n    def _calculate_sector_dominance(self, laps):\n        \"\"\"Calculate how often driver has fastest sectors\"\"\"\n        try:\n            sector_times = []\n            for col in ['Sector1Time', 'Sector2Time', 'Sector3Time']:\n                if col in laps.columns:\n                    sector_times.extend(laps[col].dropna().dt.total_seconds().tolist())\n            \n            if not sector_times:\n                return 0\n            \n            # Simple dominance score based on percentile performance\n            return np.percentile(sector_times, 25) / np.mean(sector_times)\n        except:\n            return 0\n    \n    def _calculate_tire_efficiency(self, laps):\n        \"\"\"Calculate tire management efficiency\"\"\"\n        try:\n            if 'Compound' not in laps.columns:\n                return 0.5\n            \n            # Analyze lap time degradation by compound\n            compounds = laps['Compound'].unique()\n            efficiency_scores = []\n            \n            for compound in compounds:\n                if pd.isna(compound):\n                    continue\n                    \n                compound_laps = laps[laps['Compound'] == compound]\n                if len(compound_laps) < 3:\n                    continue\n                \n                lap_times = compound_laps['LapTime'].dt.total_seconds()\n                lap_numbers = range(len(lap_times))\n                \n                # Calculate degradation rate\n                if len(lap_times) > 1:\n                    slope, _, r_value, _, _ = stats.linregress(lap_numbers, lap_times)\n                    efficiency = max(0, 1 - abs(slope))  # Lower degradation = higher efficiency\n                    efficiency_scores.append(efficiency)\n            \n            return np.mean(efficiency_scores) if efficiency_scores else 0.5\n        except:\n            return 0.5\n    \n    def create_performance_clustering(self, performance_df):\n        \"\"\"Create driver performance clusters using machine learning\"\"\"\n        if performance_df.empty or len(performance_df) < 3:\n            return None\n        \n        # Prepare data for clustering\n        features = ['Consistency_Score', 'Speed_Consistency', 'Pace_Quality', \n                   'Overtake_Score', 'Sector_Dominance', 'Tire_Efficiency']\n        \n        X = performance_df[features].fillna(0)\n        \n        # Standardize features\n        scaler = StandardScaler()\n        X_scaled = scaler.fit_transform(X)\n        \n        # Perform clustering\n        n_clusters = min(4, len(performance_df))\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n        clusters = kmeans.fit_predict(X_scaled)\n        \n        performance_df['Cluster'] = clusters\n        \n        # Create visualization\n        fig = go.Figure()\n        \n        cluster_names = ['Elite Performers', 'Consistent Drivers', 'Aggressive Racers', 'Developing Talent']\n        colors = ['#FFD700', '#00D2BE', '#FF6B6B', '#4ECDC4']\n        \n        for i in range(n_clusters):\n            cluster_data = performance_df[performance_df['Cluster'] == i]\n            \n            fig.add_trace(go.Scatter(\n                x=cluster_data['Consistency_Score'],\n                y=cluster_data['Pace_Quality'],\n                mode='markers+text',\n                text=cluster_data['Driver'],\n                textposition='top center',\n                marker=dict(\n                    size=cluster_data['Performance_Index'] * 20,\n                    color=colors[i],\n                    line=dict(width=2, color='white'),\n                    opacity=0.8\n                ),\n                name=cluster_names[i] if i < len(cluster_names) else f'Cluster {i+1}',\n                hovertemplate='<b>%{text}</b><br>' +\n                             'Consistency: %{x:.3f}<br>' +\n                             'Pace Quality: %{y:.3f}<br>' +\n                             'Performance Index: %{marker.size:.3f}<br>' +\n                             '<extra></extra>'\n            ))\n        \n        fig.update_layout(\n            title='Driver Performance Clustering Analysis',\n            xaxis_title='Consistency Score',\n            yaxis_title='Pace Quality',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            height=600\n        )\n        \n        return fig\n    \n    def create_performance_radar(self, performance_df):\n        \"\"\"Create radar chart for driver performance comparison\"\"\"\n        if performance_df.empty:\n            return None\n        \n        categories = ['Consistency', 'Speed Consistency', 'Pace Quality', \n                     'Overtaking', 'Sector Dominance', 'Tire Management']\n        \n        fig = go.Figure()\n        \n        for _, driver_data in performance_df.iterrows():\n            team_color = TEAM_COLORS.get(driver_data['Team'], '#808080')\n            \n            values = [\n                driver_data['Consistency_Score'],\n                driver_data['Speed_Consistency'],\n                driver_data['Pace_Quality'],\n                driver_data['Overtake_Score'],\n                driver_data['Sector_Dominance'],\n                driver_data['Tire_Efficiency']\n            ]\n            \n            fig.add_trace(go.Scatterpolar(\n                r=values + [values[0]],  # Close the polygon\n                theta=categories + [categories[0]],\n                fill='toself',\n                name=driver_data['Driver'],\n                line=dict(color=team_color, width=3),\n                fillcolor=team_color,\n                opacity=0.3\n            ))\n        \n        fig.update_layout(\n            polar=dict(\n                radialaxis=dict(\n                    visible=True,\n                    range=[0, 1],\n                    gridcolor='rgba(255,255,255,0.2)'\n                ),\n                angularaxis=dict(\n                    gridcolor='rgba(255,255,255,0.2)'\n                )\n            ),\n            showlegend=True,\n            title='Driver Performance Radar Comparison',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            height=600\n        )\n        \n        return fig\n    \n    def analyze_race_pace_evolution(self, drivers):\n        \"\"\"Analyze how race pace evolves throughout the session\"\"\"\n        pace_data = []\n        \n        for driver in drivers:\n            try:\n                driver_laps = self.laps.pick_drivers(driver)\n                valid_laps = driver_laps[driver_laps['LapTime'].notna()]\n                \n                if len(valid_laps) < 5:\n                    continue\n                \n                # Calculate rolling average pace (5-lap window)\n                lap_times = valid_laps['LapTime'].dt.total_seconds()\n                rolling_pace = lap_times.rolling(window=5, center=True).mean()\n                \n                for i, (_, lap) in enumerate(valid_laps.iterrows()):\n                    if not pd.isna(rolling_pace.iloc[i]):\n                        pace_data.append({\n                            'Driver': driver,\n                            'Lap': lap['LapNumber'],\n                            'Pace': rolling_pace.iloc[i],\n                            'Fuel_Load': 1 - (i / len(valid_laps)),  # Estimated fuel load\n                            'Stint': self._get_stint_number(lap, valid_laps)\n                        })\n                        \n            except Exception as e:\n                continue\n        \n        return pd.DataFrame(pace_data)\n    \n    def _get_stint_number(self, lap, all_laps):\n        \"\"\"Determine stint number based on tire compound changes\"\"\"\n        try:\n            current_compound = lap['Compound']\n            stint = 1\n            \n            for _, prev_lap in all_laps.iterrows():\n                if prev_lap['LapNumber'] >= lap['LapNumber']:\n                    break\n                if prev_lap['Compound'] != current_compound:\n                    stint += 1\n                    current_compound = prev_lap['Compound']\n            \n            return stint\n        except:\n            return 1","size_bytes":11770},"utils/formatters.py":{"content":"\"\"\"\nFormatting utilities for F1 data display\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom datetime import timedelta\n\ndef format_lap_time(lap_time):\n    \"\"\"Format lap time to M:SS.mmm format\"\"\"\n    if pd.isna(lap_time):\n        return \"N/A\"\n    \n    if isinstance(lap_time, str):\n        return lap_time\n    \n    if isinstance(lap_time, timedelta):\n        total_seconds = lap_time.total_seconds()\n    else:\n        total_seconds = float(lap_time)\n    \n    if total_seconds <= 0:\n        return \"N/A\"\n    \n    minutes = int(total_seconds // 60)\n    seconds = total_seconds % 60\n    \n    return f\"{minutes}:{seconds:06.3f}\"\n\ndef format_sector_time(sector_time):\n    \"\"\"Format sector time to SS.mmm format\"\"\"\n    if pd.isna(sector_time):\n        return \"N/A\"\n    \n    if isinstance(sector_time, timedelta):\n        total_seconds = sector_time.total_seconds()\n    else:\n        total_seconds = float(sector_time)\n    \n    if total_seconds <= 0:\n        return \"N/A\"\n    \n    return f\"{total_seconds:06.3f}\"\n\ndef get_lap_time_color_class(position):\n    \"\"\"Get CSS class for lap time based on position\"\"\"\n    if position == 1:\n        return \"fastest-lap\"\n    elif position == 2:\n        return \"second-lap\"\n    elif position == 3:\n        return \"third-lap\"\n    else:\n        return \"\"\n\ndef format_gap_time(gap_seconds):\n    \"\"\"Format gap time between drivers\"\"\"\n    if pd.isna(gap_seconds) or gap_seconds == 0:\n        return \"0.000\"\n    \n    if gap_seconds >= 60:\n        minutes = int(gap_seconds // 60)\n        seconds = gap_seconds % 60\n        return f\"+{minutes}:{seconds:06.3f}\"\n    else:\n        return f\"+{gap_seconds:.3f}\"\n\ndef get_position_change_text(start_pos, end_pos):\n    \"\"\"Get formatted text for position changes\"\"\"\n    change = start_pos - end_pos\n    if change > 0:\n        return f\"📈 +{change}\", \"success\"\n    elif change < 0:\n        return f\"📉 {change}\", \"error\"\n    else:\n        return \"➡️ 0\", \"info\"\n\ndef format_tire_age(tire_life):\n    \"\"\"Format tire age display\"\"\"\n    if pd.isna(tire_life) or tire_life == 0:\n        return \"New\"\n    else:\n        return f\"{int(tire_life)} laps\"\n\ndef format_average_lap_time(total_seconds):\n    \"\"\"Format average lap time in M:SS.mmm format for Advanced Analytics\"\"\"\n    if pd.isna(total_seconds) or total_seconds <= 0:\n        return \"N/A\"\n    \n    # Convert to float if it's not already\n    try:\n        seconds = float(total_seconds)\n    except (ValueError, TypeError):\n        return \"N/A\"\n    \n    minutes = int(seconds // 60)\n    remaining_seconds = seconds % 60\n    \n    return f\"{minutes}:{remaining_seconds:06.3f}\"\n\ndef format_delta_time(time_diff):\n    \"\"\"Format time difference for comparisons\"\"\"\n    if pd.isna(time_diff):\n        return \"N/A\"\n    \n    if abs(time_diff) < 0.001:\n        return \"0.000\"\n    \n    sign = \"+\" if time_diff > 0 else \"\"\n    return f\"{sign}{time_diff:.3f}s\"","size_bytes":2869},"utils/race_strategy.py":{"content":"\"\"\"\nRace Strategy Analysis Module\nProvides comprehensive strategy analysis including pit stops, tire strategy, and race pace\n\"\"\"\n\nimport fastf1\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom .constants import TIRE_COLORS, TEAM_COLORS\n\nclass RaceStrategyAnalyzer:\n    \"\"\"Advanced race strategy analysis\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        self.laps = session.laps\n        self.results = session.results\n        \n    def analyze_pit_stop_strategies(self):\n        \"\"\"Analyze pit stop strategies for all drivers\"\"\"\n        pit_strategies = {}\n        \n        for driver in self.laps['Driver'].unique():\n            if pd.isna(driver):\n                continue\n                \n            driver_laps = self.laps.pick_driverss(driver)\n            pit_stops = []\n            \n            # Find pit stops by looking for compound changes\n            prev_compound = None\n            for idx, lap in driver_laps.iterrows():\n                current_compound = lap['Compound']\n                \n                if prev_compound is not None and current_compound != prev_compound:\n                    pit_stops.append({\n                        'lap_number': lap['LapNumber'],\n                        'old_compound': prev_compound,\n                        'new_compound': current_compound,\n                        'pit_time': lap['PitInTime'] if pd.notna(lap['PitInTime']) else None,\n                        'pit_out_time': lap['PitOutTime'] if pd.notna(lap['PitOutTime']) else None\n                    })\n                \n                prev_compound = current_compound\n            \n            # Calculate stint lengths\n            stints = []\n            stint_start = 1\n            \n            for pit_stop in pit_stops:\n                stint_length = pit_stop['lap_number'] - stint_start\n                stints.append({\n                    'stint_number': len(stints) + 1,\n                    'start_lap': stint_start,\n                    'end_lap': pit_stop['lap_number'] - 1,\n                    'length': stint_length,\n                    'compound': pit_stop['old_compound']\n                })\n                stint_start = pit_stop['lap_number']\n            \n            # Add final stint\n            final_lap = driver_laps['LapNumber'].max()\n            if stint_start <= final_lap:\n                stints.append({\n                    'stint_number': len(stints) + 1,\n                    'start_lap': stint_start,\n                    'end_lap': final_lap,\n                    'length': final_lap - stint_start + 1,\n                    'compound': driver_laps.iloc[-1]['Compound']\n                })\n            \n            pit_strategies[driver] = {\n                'pit_stops': pit_stops,\n                'stints': stints,\n                'total_pit_stops': len(pit_stops),\n                'strategy_type': self._classify_strategy(stints)\n            }\n        \n        return pit_strategies\n    \n    def _classify_strategy(self, stints):\n        \"\"\"Classify pit strategy type\"\"\"\n        num_stints = len(stints)\n        \n        if num_stints == 1:\n            return \"No-stop\"\n        elif num_stints == 2:\n            return \"One-stop\"\n        elif num_stints == 3:\n            return \"Two-stop\"\n        else:\n            return f\"{num_stints-1}-stop\"\n    \n    def analyze_undercut_overcut_effectiveness(self):\n        \"\"\"Analyze undercut and overcut strategies\"\"\"\n        strategies = {}\n        pit_strategies = self.analyze_pit_stop_strategies()\n        \n        for driver, strategy_data in pit_strategies.items():\n            if not strategy_data['pit_stops']:\n                continue\n                \n            driver_analysis = []\n            \n            for pit_stop in strategy_data['pit_stops']:\n                pit_lap = pit_stop['lap_number']\n                \n                # Analyze position changes around pit stop\n                positions_before = []\n                positions_after = []\n                \n                # Get positions 3 laps before and after pit stop\n                for lap_offset in range(-3, 4):\n                    target_lap = pit_lap + lap_offset\n                    \n                    lap_data = self.laps[\n                        (self.laps['Driver'] == driver) & \n                        (self.laps['LapNumber'] == target_lap)\n                    ]\n                    \n                    if not lap_data.empty:\n                        position = lap_data.iloc[0]['Position']\n                        if lap_offset < 0:\n                            positions_before.append(position)\n                        elif lap_offset > 0:\n                            positions_after.append(position)\n                \n                # Calculate effectiveness\n                if positions_before and positions_after:\n                    avg_pos_before = np.mean(positions_before)\n                    avg_pos_after = np.mean(positions_after)\n                    position_change = avg_pos_before - avg_pos_after\n                    \n                    driver_analysis.append({\n                        'pit_lap': pit_lap,\n                        'position_change': position_change,\n                        'effectiveness': 'positive' if position_change > 0 else 'negative',\n                        'magnitude': abs(position_change)\n                    })\n            \n            strategies[driver] = driver_analysis\n        \n        return strategies\n    \n    def create_strategy_timeline_plot(self):\n        \"\"\"Create comprehensive strategy timeline visualization\"\"\"\n        pit_strategies = self.analyze_pit_stop_strategies()\n        \n        fig = go.Figure()\n        \n        y_position = 0\n        driver_positions = {}\n        \n        for driver, strategy_data in pit_strategies.items():\n            driver_positions[driver] = y_position\n            \n            # Plot stints as horizontal bars\n            for stint in strategy_data['stints']:\n                compound = stint['compound']\n                color = TIRE_COLORS.get(compound, '#808080')\n                \n                fig.add_trace(go.Scatter(\n                    x=[stint['start_lap'], stint['end_lap']],\n                    y=[y_position, y_position],\n                    mode='lines',\n                    line=dict(color=color, width=8),\n                    name=f\"{driver} - {compound}\",\n                    showlegend=False,\n                    hovertemplate=f\"Driver: {driver}<br>Compound: {compound}<br>Stint: {stint['start_lap']}-{stint['end_lap']}<br>Length: {stint['length']} laps<extra></extra>\"\n                ))\n            \n            # Mark pit stops\n            for pit_stop in strategy_data['pit_stops']:\n                fig.add_trace(go.Scatter(\n                    x=[pit_stop['lap_number']],\n                    y=[y_position],\n                    mode='markers',\n                    marker=dict(\n                        color='white',\n                        size=10,\n                        symbol='diamond',\n                        line=dict(color='black', width=2)\n                    ),\n                    name=f\"{driver} Pit Stop\",\n                    showlegend=False,\n                    hovertemplate=f\"Pit Stop<br>Driver: {driver}<br>Lap: {pit_stop['lap_number']}<br>Change: {pit_stop['old_compound']} → {pit_stop['new_compound']}<extra></extra>\"\n                ))\n            \n            y_position += 1\n        \n        # Add driver labels\n        fig.update_layout(\n            title='Race Strategy Timeline - Tire Compounds and Pit Stops',\n            xaxis_title='Lap Number',\n            yaxis=dict(\n                tickvals=list(driver_positions.values()),\n                ticktext=list(driver_positions.keys()),\n                title='Drivers'\n            ),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            height=max(600, len(pit_strategies) * 40),\n            showlegend=False,\n            hovermode='closest'\n        )\n        \n        fig.update_xaxes(gridcolor='rgba(255,255,255,0.1)')\n        fig.update_yaxes(gridcolor='rgba(255,255,255,0.1)')\n        \n        return fig\n    \n    def analyze_fuel_effect_on_pace(self):\n        \"\"\"Analyze how fuel load affects lap times throughout the race\"\"\"\n        fuel_analysis = {}\n        \n        for driver in self.laps['Driver'].unique():\n            if pd.isna(driver):\n                continue\n                \n            driver_laps = self.laps.pick_driverss(driver)\n            valid_laps = driver_laps[driver_laps['LapTime'].notna()]\n            \n            if len(valid_laps) < 5:\n                continue\n            \n            lap_numbers = valid_laps['LapNumber'].values\n            lap_times = valid_laps['LapTime'].dt.total_seconds().values\n            \n            # Calculate theoretical fuel effect (assuming linear fuel consumption)\n            race_distance = lap_numbers.max()\n            \n            # Estimate fuel load effect (rough approximation)\n            fuel_loads = []\n            for lap_num in lap_numbers:\n                remaining_laps = race_distance - lap_num\n                estimated_fuel_load = remaining_laps / race_distance\n                fuel_loads.append(estimated_fuel_load)\n            \n            # Calculate pace improvement over the race\n            if len(lap_times) > 1:\n                pace_trend = np.polyfit(lap_numbers, lap_times, 1)[0]\n                \n                fuel_analysis[driver] = {\n                    'pace_trend': pace_trend,  # seconds per lap improvement\n                    'total_improvement': pace_trend * (lap_numbers.max() - lap_numbers.min()),\n                    'average_pace': np.mean(lap_times),\n                    'consistency': np.std(lap_times),\n                    'laps_analyzed': len(valid_laps)\n                }\n        \n        return fuel_analysis\n    \n    def create_pace_evolution_plot(self):\n        \"\"\"Create pace evolution plot showing fuel effect\"\"\"\n        fuel_analysis = self.analyze_fuel_effect_on_pace()\n        \n        fig = go.Figure()\n        \n        colors = ['#DC0000', '#00D2BE', '#FF8700', '#1E41FF', '#0090FF', '#006F62', '#808080', '#1660AD', '#87CEEB', '#00E701']\n        color_idx = 0\n        \n        for driver, analysis in fuel_analysis.items():\n            driver_laps = self.laps.pick_driverss(driver)\n            valid_laps = driver_laps[driver_laps['LapTime'].notna()]\n            \n            if len(valid_laps) < 5:\n                continue\n            \n            lap_numbers = valid_laps['LapNumber'].values\n            lap_times = valid_laps['LapTime'].dt.total_seconds().values\n            \n            # Create trend line\n            trend_line = np.poly1d(np.polyfit(lap_numbers, lap_times, 1))\n            trend_y = trend_line(lap_numbers)\n            \n            fig.add_trace(go.Scatter(\n                x=lap_numbers,\n                y=lap_times,\n                mode='markers',\n                marker=dict(color=colors[color_idx % len(colors)], size=6, opacity=0.6),\n                name=f'{driver} (actual)',\n                showlegend=True\n            ))\n            \n            fig.add_trace(go.Scatter(\n                x=lap_numbers,\n                y=trend_y,\n                mode='lines',\n                line=dict(color=colors[color_idx % len(colors)], width=2, dash='dash'),\n                name=f'{driver} (trend)',\n                showlegend=False\n            ))\n            \n            color_idx += 1\n        \n        fig.update_layout(\n            title='Pace Evolution Throughout the Race (Fuel Effect Analysis)',\n            xaxis_title='Lap Number',\n            yaxis_title='Lap Time (seconds)',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            height=600,\n            hovermode='closest'\n        )\n        \n        fig.update_xaxes(gridcolor='rgba(255,255,255,0.1)')\n        fig.update_yaxes(gridcolor='rgba(255,255,255,0.1)')\n        \n        return fig","size_bytes":12120},"utils/stress_index.py":{"content":"\"\"\"\nDriver Stress Index Analysis Module\nAdvanced driver stress calculation and visualization for F1 data\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom utils.constants import TEAM_COLORS\n\n\nclass DriverStressAnalyzer:\n    \"\"\"Advanced driver stress index analysis for F1 performance\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        \n    def calculate_driver_stress_index(self):\n        \"\"\"Calculate comprehensive Driver Stress Index (DSI) for all drivers\"\"\"\n        drivers = self.session.drivers\n        results = []\n\n        for driver in drivers:\n            driver_laps = self.session.laps.pick_drivers(driver)\n            fastest_lap = driver_laps.pick_fastest()\n\n            if fastest_lap is None or fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\n                continue\n\n            try:\n                telemetry = fastest_lap.get_car_data().add_distance()\n            except (KeyError, AttributeError):\n                continue\n\n            # Enhanced telemetry analysis\n            speed_data = telemetry['Speed']\n            brake_data = telemetry['Brake']\n            throttle_data = telemetry['Throttle']\n            distance_data = telemetry['Distance']\n\n            # Advanced calculations\n            total_distance = distance_data.max() - distance_data.min()\n            \n            # Weighted metrics based on distance and intensity\n            braking_weighted = (brake_data.sum() * (distance_data.diff().mean())) / total_distance * 100\n            high_throttle_weighted = (len(throttle_data[throttle_data > 90]) * \n                                    distance_data.diff().mean()) / total_distance * 100\n            \n            # Critical speed analysis\n            critical_speed_median = speed_data[(brake_data > 0) | (throttle_data > 90)].median()\n            \n            # Enhanced stress calculations\n            speed_variance = speed_data.var()\n            gear_changes = len(telemetry['nGear'].diff()[telemetry['nGear'].diff() != 0])\n            \n            # Comprehensive Driver Stress Index\n            base_stress = (braking_weighted + (100 - high_throttle_weighted)) / max(critical_speed_median, 1)\n            variance_factor = speed_variance / 1000  # Normalize speed variance\n            gear_stress = gear_changes / total_distance * 1000  # Gear changes per km\n            \n            driver_stress_index = base_stress + variance_factor + gear_stress\n            \n            # Additional performance metrics\n            consistency_index = 100 - (speed_data.std() / speed_data.mean() * 100)\n            aggression_index = (braking_weighted + gear_stress) / 2\n            smoothness_index = 100 - variance_factor\n            \n            driver_info = self.session.get_driver(driver)\n            driver_name = driver_info['LastName'][:3].upper()\n            team_name = driver_info.get('TeamName', 'Unknown')\n\n            results.append({\n                'Driver': driver_name,\n                'Team': team_name,\n                'Braking_Percentage': braking_weighted,\n                'High_Throttle_Percentage': high_throttle_weighted,\n                'Critical_Speed_Median': critical_speed_median,\n                'Driver_Stress_Index': driver_stress_index,\n                'Consistency_Index': consistency_index,\n                'Aggression_Index': aggression_index,\n                'Smoothness_Index': smoothness_index,\n                'Gear_Changes_Per_Km': gear_stress,\n                'Speed_Variance': speed_variance\n            })\n\n        return pd.DataFrame(results)\n\n    def create_stress_analysis_visualizations(self, df_stress, session_info):\n        \"\"\"Create comprehensive stress analysis visualizations\"\"\"\n        \n        # Create subplot layout\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=[\n                'Driver Stress Index Ranking',\n                'Stress Components Analysis',\n                'Driving Style Comparison', \n                'Performance Correlation Matrix'\n            ],\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": False}, {\"type\": \"heatmap\"}]]\n        )\n\n        # Sort by stress index for better visualization\n        df_sorted = df_stress.sort_values('Driver_Stress_Index', ascending=True)\n        \n        # Get team colors\n        colors = [TEAM_COLORS.get(team, '#888888') for team in df_sorted['Team']]\n\n        # 1. Driver Stress Index Bar Chart\n        fig.add_trace(\n            go.Bar(\n                y=df_sorted['Driver'],\n                x=df_sorted['Driver_Stress_Index'],\n                orientation='h',\n                name='Stress Index',\n                marker_color=colors,\n                text=[f\"{val:.2f}\" for val in df_sorted['Driver_Stress_Index']],\n                textposition='outside',\n                hovertemplate='<b>%{y}</b><br>Stress Index: %{x:.3f}<br>' +\n                             'Critical Speed: %{customdata:.1f} km/h<extra></extra>',\n                customdata=df_sorted['Critical_Speed_Median']\n            ),\n            row=1, col=1\n        )\n\n        # 2. Stress Components Stacked Bar\n        fig.add_trace(\n            go.Bar(\n                x=df_stress['Driver'],\n                y=df_stress['Braking_Percentage'],\n                name='Braking %',\n                marker_color='#FF6B6B',\n                offsetgroup=1\n            ),\n            row=1, col=2\n        )\n        \n        fig.add_trace(\n            go.Bar(\n                x=df_stress['Driver'],\n                y=df_stress['Aggression_Index'],\n                name='Aggression',\n                marker_color='#4ECDC4',\n                offsetgroup=2\n            ),\n            row=1, col=2\n        )\n\n        # 3. Driving Style Scatter Plot\n        fig.add_trace(\n            go.Scatter(\n                x=df_stress['Consistency_Index'],\n                y=df_stress['Smoothness_Index'],\n                mode='markers+text',\n                text=df_stress['Driver'],\n                textposition='top center',\n                marker=dict(\n                    size=df_stress['Driver_Stress_Index'] * 3,\n                    color=[TEAM_COLORS.get(team, '#888888') for team in df_stress['Team']],\n                    line=dict(width=2, color='white'),\n                    opacity=0.8\n                ),\n                name='Driving Style',\n                hovertemplate='<b>%{text}</b><br>' +\n                             'Consistency: %{x:.1f}<br>' +\n                             'Smoothness: %{y:.1f}<br>' +\n                             'Stress Index: %{marker.size:.1f}<extra></extra>'\n            ),\n            row=2, col=1\n        )\n\n        # 4. Correlation Heatmap\n        correlation_metrics = ['Driver_Stress_Index', 'Consistency_Index', \n                             'Aggression_Index', 'Smoothness_Index']\n        corr_matrix = df_stress[correlation_metrics].corr()\n        \n        fig.add_trace(\n            go.Heatmap(\n                z=corr_matrix.values,\n                x=['Stress', 'Consistency', 'Aggression', 'Smoothness'],\n                y=['Stress', 'Consistency', 'Aggression', 'Smoothness'],\n                colorscale='RdBu',\n                zmid=0,\n                text=np.round(corr_matrix.values, 3),\n                texttemplate=\"%{text}\",\n                textfont={\"size\": 12, \"color\": \"white\"},\n                hoverongaps=False\n            ),\n            row=2, col=2\n        )\n\n        # Update layout\n        fig.update_layout(\n            title=dict(\n                text=f\"<b>Driver Stress Analysis - {session_info}</b>\",\n                x=0.5,\n                font=dict(size=24, color='white', family='Inter')\n            ),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            showlegend=True,\n            height=900,\n            margin=dict(t=100, b=50, l=50, r=50)\n        )\n\n        # Update axes styling\n        for i in range(1, 3):\n            for j in range(1, 3):\n                fig.update_xaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    row=i, col=j\n                )\n                fig.update_yaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    row=i, col=j\n                )\n\n        return fig\n\n    def create_stress_ranking_chart(self, df_stress):\n        \"\"\"Create a professional stress ranking visualization\"\"\"\n        \n        df_sorted = df_stress.sort_values('Driver_Stress_Index', ascending=False)\n        \n        # Create color gradient based on stress level\n        colors = px.colors.sequential.Plasma\n        normalized_stress = (df_sorted['Driver_Stress_Index'] - df_sorted['Driver_Stress_Index'].min()) / \\\n                          (df_sorted['Driver_Stress_Index'].max() - df_sorted['Driver_Stress_Index'].min())\n        \n        fig = go.Figure()\n\n        # Add bars with gradient colors\n        fig.add_trace(go.Bar(\n            x=df_sorted['Driver'],\n            y=df_sorted['Driver_Stress_Index'],\n            marker=dict(\n                color=normalized_stress,\n                colorscale='Plasma',\n                showscale=True,\n                colorbar=dict(\n                    title=\"Stress Level\",\n                    titlefont=dict(color='white'),\n                    tickfont=dict(color='white')\n                ),\n                line=dict(width=1, color='white')\n            ),\n            text=[f\"{val:.3f}\" for val in df_sorted['Driver_Stress_Index']],\n            textposition='outside',\n            textfont=dict(color='white', size=12),\n            hovertemplate='<b>%{x}</b><br>' +\n                         'Stress Index: %{y:.3f}<br>' +\n                         'Team: %{customdata}<extra></extra>',\n            customdata=df_sorted['Team']\n        ))\n\n        # Add mean line\n        mean_stress = df_sorted['Driver_Stress_Index'].mean()\n        fig.add_hline(\n            y=mean_stress,\n            line_dash=\"dash\",\n            line_color=\"red\",\n            annotation_text=f\"Mean: {mean_stress:.3f}\",\n            annotation_position=\"top right\",\n            annotation_font_color=\"white\"\n        )\n\n        fig.update_layout(\n            title=dict(\n                text=\"<b>Driver Stress Index Ranking</b>\",\n                x=0.5,\n                font=dict(size=22, color='white', family='Inter')\n            ),\n            xaxis=dict(\n                title='Driver',\n                color='white',\n                tickangle=45,\n                gridcolor='rgba(128, 128, 128, 0.2)'\n            ),\n            yaxis=dict(\n                title='Stress Index',\n                color='white',\n                gridcolor='rgba(128, 128, 128, 0.2)'\n            ),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            height=600,\n            margin=dict(t=80, b=100, l=50, r=50)\n        )\n\n        return fig","size_bytes":11300},"utils/tire_performance.py":{"content":"\"\"\"\nTire Performance Analysis Module\nProfessional F1 tire performance analytics and visualization\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom utils.constants import TEAM_COLORS\n\n\nclass TirePerformanceAnalyzer:\n    \"\"\"Advanced tire performance analysis for F1 data\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        \n    def calculate_tire_performance(self):\n        \"\"\"Calculate comprehensive tire performance metrics for all drivers\"\"\"\n        drivers = self.session.drivers\n        results = []\n\n        for driver in drivers:\n            driver_laps = self.session.laps.pick_drivers(driver)\n            fastest_lap = driver_laps.pick_fastest()\n            \n            if fastest_lap is None or fastest_lap.empty or pd.isna(fastest_lap['DriverNumber']):\n                continue\n            \n            try:\n                telemetry = fastest_lap.get_car_data().add_distance()\n            except (KeyError, AttributeError):\n                continue\n\n            # Enhanced metrics calculation\n            speed_data = telemetry['Speed']\n            acceleration_data = speed_data.diff() / telemetry['Distance'].diff()\n            braking_data = telemetry['Brake']\n            throttle_data = telemetry['Throttle']\n\n            # Advanced Tire Stress Index\n            braking_factor = braking_data.mean() / 100.0  # Normalize to 0-1\n            acceleration_stress = acceleration_data.abs().mean()\n            tire_stress_index = (speed_data.mean() * acceleration_stress) * (1 + braking_factor)\n\n            # Tire Temperature Simulation (based on speed, braking, and throttle)\n            thermal_load = (speed_data.mean() * 0.4 + \n                           braking_data.mean() * 0.4 + \n                           throttle_data.mean() * 0.2)\n            tire_temperature = 80 + thermal_load * 0.8  # Base temp + thermal load\n\n            # Tire Efficiency (speed per unit stress)\n            tire_efficiency = speed_data.mean() / (1 + tire_stress_index) if tire_stress_index > 0 else 0\n\n            # Tire Wear Index (comprehensive wear calculation)\n            distance_factor = telemetry['Distance'].max() / 1000  # Convert to km\n            tire_wear_index = (tire_stress_index * 0.6 + \n                              braking_factor * 100 * 0.3 + \n                              distance_factor * 0.1)\n\n            # Grip Level Estimation\n            max_lateral_g = acceleration_data.abs().quantile(0.95)\n            grip_level = min(100, max_lateral_g * 50)  # Scaled grip estimation\n\n            driver_info = self.session.get_driver(driver)\n            driver_name = driver_info['LastName'][:3].upper()\n            team_name = driver_info.get('TeamName', 'Unknown')\n            \n            results.append({\n                'Driver': driver_name,\n                'Team': team_name,\n                'Tire_Stress_Index': tire_stress_index,\n                'Tire_Temperature': tire_temperature,\n                'Tire_Efficiency': tire_efficiency,\n                'Tire_Wear_Index': tire_wear_index,\n                'Grip_Level': grip_level,\n                'Avg_Speed': speed_data.mean(),\n                'Peak_Acceleration': acceleration_data.abs().max(),\n                'Braking_Intensity': braking_factor * 100\n            })\n\n        return pd.DataFrame(results)\n\n    def create_enhanced_tire_performance_visualizations(self, df_tires, session_info):\n        \"\"\"Create comprehensive tire performance visualizations\"\"\"\n        \n        # Create subplot layout\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=[\n                'Tire Stress Index by Driver',\n                'Tire Temperature Analysis', \n                'Tire Efficiency Comparison',\n                'Tire Wear Index'\n            ],\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n        )\n\n        # Get team colors for drivers\n        colors = []\n        for _, row in df_tires.iterrows():\n            team = row['Team']\n            color = TEAM_COLORS.get(team, '#888888')\n            colors.append(color)\n\n        # 1. Tire Stress Index\n        fig.add_trace(\n            go.Bar(\n                x=df_tires['Driver'],\n                y=df_tires['Tire_Stress_Index'],\n                name='Stress Index',\n                marker_color=colors,\n                text=[f\"{val:.1f}\" for val in df_tires['Tire_Stress_Index']],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Stress Index: %{y:.2f}<extra></extra>'\n            ),\n            row=1, col=1\n        )\n\n        # 2. Tire Temperature\n        fig.add_trace(\n            go.Scatter(\n                x=df_tires['Driver'],\n                y=df_tires['Tire_Temperature'],\n                mode='markers+lines',\n                name='Temperature',\n                marker=dict(\n                    size=12,\n                    color=df_tires['Tire_Temperature'],\n                    colorscale='Thermal',\n                    showscale=False,\n                    line=dict(width=2, color='white')\n                ),\n                line=dict(color='#FF6B6B', width=3),\n                text=[f\"{val:.1f}°C\" for val in df_tires['Tire_Temperature']],\n                textposition='top center',\n                hovertemplate='<b>%{x}</b><br>Temperature: %{y:.1f}°C<extra></extra>'\n            ),\n            row=1, col=2\n        )\n\n        # 3. Tire Efficiency\n        efficiency_colors = px.colors.sequential.Viridis\n        fig.add_trace(\n            go.Bar(\n                x=df_tires['Driver'],\n                y=df_tires['Tire_Efficiency'],\n                name='Efficiency',\n                marker=dict(\n                    color=df_tires['Tire_Efficiency'],\n                    colorscale='Viridis',\n                    showscale=False,\n                    line=dict(width=1, color='white')\n                ),\n                text=[f\"{val:.2f}\" for val in df_tires['Tire_Efficiency']],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Efficiency: %{y:.3f}<extra></extra>'\n            ),\n            row=2, col=1\n        )\n\n        # 4. Tire Wear Index\n        fig.add_trace(\n            go.Bar(\n                x=df_tires['Driver'],\n                y=df_tires['Tire_Wear_Index'],\n                name='Wear Index',\n                marker=dict(\n                    color=df_tires['Tire_Wear_Index'],\n                    colorscale='Plasma',\n                    showscale=False,\n                    line=dict(width=1, color='white')\n                ),\n                text=[f\"{val:.1f}\" for val in df_tires['Tire_Wear_Index']],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Wear Index: %{y:.2f}<extra></extra>'\n            ),\n            row=2, col=2\n        )\n\n        # Update layout\n        fig.update_layout(\n            title=dict(\n                text=f\"<b>Tire Performance Analysis - {session_info}</b>\",\n                x=0.5,\n                font=dict(size=24, color='white', family='Inter')\n            ),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            showlegend=False,\n            height=800,\n            margin=dict(t=100, b=50, l=50, r=50)\n        )\n\n        # Update axes\n        for i in range(1, 3):\n            for j in range(1, 3):\n                fig.update_xaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    tickangle=45,\n                    row=i, col=j\n                )\n                fig.update_yaxes(\n                    gridcolor='rgba(128, 128, 128, 0.2)',\n                    showgrid=True,\n                    zeroline=False,\n                    color='white',\n                    row=i, col=j\n                )\n\n        return fig\n\n    def create_tire_comparison_heatmap(self, df_tires):\n        \"\"\"Create a heatmap comparing all tire metrics\"\"\"\n        \n        # Prepare data for heatmap\n        metrics = ['Tire_Stress_Index', 'Tire_Temperature', 'Tire_Efficiency', \n                  'Tire_Wear_Index', 'Grip_Level']\n        \n        # Normalize data for better visualization\n        heatmap_data = df_tires[metrics].copy()\n        for col in metrics:\n            heatmap_data[col] = (heatmap_data[col] - heatmap_data[col].min()) / \\\n                               (heatmap_data[col].max() - heatmap_data[col].min())\n\n        fig = go.Figure(data=go.Heatmap(\n            z=heatmap_data.values.T,\n            x=df_tires['Driver'],\n            y=['Stress Index', 'Temperature', 'Efficiency', 'Wear Index', 'Grip Level'],\n            colorscale='RdYlBu_r',\n            text=np.round(heatmap_data.values.T, 3),\n            texttemplate=\"%{text}\",\n            textfont={\"size\": 10, \"color\": \"white\"},\n            hoverongaps=False,\n            hovertemplate='<b>%{y}</b><br>Driver: %{x}<br>Normalized Value: %{z:.3f}<extra></extra>'\n        ))\n\n        fig.update_layout(\n            title=dict(\n                text=\"<b>Tire Performance Heatmap - Normalized Metrics</b>\",\n                x=0.5,\n                font=dict(size=20, color='white', family='Inter')\n            ),\n            xaxis=dict(title='Driver', color='white'),\n            yaxis=dict(title='Metrics', color='white'),\n            font=dict(family='Inter', color='white'),\n            paper_bgcolor='#0E1117',\n            plot_bgcolor='#0E1117',\n            height=500\n        )\n\n        return fig","size_bytes":9739},"utils/track_dominance.py":{"content":"\"\"\"\nTrack dominance map visualization for F1 analysis\n\"\"\"\n\nimport plotly.graph_objects as go\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\nimport streamlit as st\nfrom .constants import TEAM_COLORS, DRIVER_TEAMS\n\ndef interpolate_track_coordinates(X, Y, num_points=2000):\n    \"\"\"Interpolate track coordinates for smooth visualization\"\"\"\n    try:\n        # Remove NaN values\n        mask = ~(np.isnan(X) | np.isnan(Y))\n        X_clean = X[mask]\n        Y_clean = Y[mask]\n        \n        if len(X_clean) < 4:  # Need at least 4 points for cubic interpolation\n            return X_clean, Y_clean, np.linspace(0, 1, len(X_clean))\n        \n        # Calculate cumulative distance\n        dist = np.sqrt(np.diff(X_clean)**2 + np.diff(Y_clean)**2)\n        cumdist = np.insert(np.cumsum(dist), 0, 0)\n        \n        # Create interpolation functions\n        fx = interp1d(cumdist, X_clean, kind='cubic', fill_value='extrapolate')\n        fy = interp1d(cumdist, Y_clean, kind='cubic', fill_value='extrapolate')\n        \n        # Create uniform distance array\n        uniform_dist = np.linspace(cumdist[0], cumdist[-1], num_points)\n        \n        # Interpolate coordinates\n        X_new = fx(uniform_dist)\n        Y_new = fy(uniform_dist)\n        \n        return X_new, Y_new, uniform_dist\n    \n    except Exception as e:\n        st.error(f\"Error interpolating track coordinates: {str(e)}\")\n        return X, Y, np.linspace(0, 1, len(X))\n\ndef create_track_dominance_map(data_loader, drivers, num_minisectors=200, show_track_outline=True):\n    \"\"\"Create professional track dominance map showing fastest mini-sectors with enhanced visualization\"\"\"\n    try:\n        telemetry_data = data_loader.get_fastest_lap_telemetry(drivers)\n        \n        if not telemetry_data:\n            return None\n        \n        # Prepare interpolated telemetry for each driver\n        driver_telemetry = {}\n        driver_lap_times = {}\n        \n        for driver in drivers:\n            if driver not in telemetry_data:\n                continue\n                \n            telemetry = telemetry_data[driver]\n            \n            if 'X' not in telemetry.columns or 'Y' not in telemetry.columns or 'Speed' not in telemetry.columns:\n                continue\n            \n            # Get lap time for this driver\n            try:\n                driver_laps = data_loader.session.laps.pick_drivers(driver)\n                fastest_lap = driver_laps.pick_fastest()\n                lap_time = fastest_lap['LapTime'].total_seconds()\n                driver_lap_times[driver] = lap_time\n            except:\n                driver_lap_times[driver] = float('inf')\n            \n            # Interpolate track coordinates and speed\n            X_interp, Y_interp, dist = interpolate_track_coordinates(\n                telemetry['X'].values, \n                telemetry['Y'].values, \n                num_minisectors * 2  # Higher resolution for smoother visualization\n            )\n            \n            # Interpolate speed data\n            if len(telemetry['Speed']) > 1:\n                speed_interp_func = interp1d(\n                    np.linspace(0, 1, len(telemetry)), \n                    telemetry['Speed'].values, \n                    kind='cubic', \n                    fill_value='extrapolate'\n                )\n                speed_interp = speed_interp_func(np.linspace(0, 1, len(X_interp)))\n            else:\n                speed_interp = np.full(len(X_interp), telemetry['Speed'].iloc[0])\n            \n            driver_telemetry[driver] = {\n                'X': X_interp,\n                'Y': Y_interp,\n                'Speed': speed_interp,\n                'Distance': np.linspace(0, 1, len(X_interp))\n            }\n        \n        if not driver_telemetry:\n            return None\n        \n        fig = go.Figure()\n        \n        # Show track outline first with enhanced styling\n        if show_track_outline:\n            first_driver = list(driver_telemetry.keys())[0]\n            outline_data = driver_telemetry[first_driver]\n            \n            fig.add_trace(go.Scatter(\n                x=outline_data['X'],\n                y=outline_data['Y'],\n                mode='lines',\n                line=dict(\n                    color='rgba(255,255,255,0.15)', \n                    width=3,\n                    dash='dot'\n                ),\n                name='Track Layout',\n                showlegend=False,\n                hoverinfo='skip'\n            ))\n        \n        # Create mini-sectors and find fastest driver for each with enhanced visualization\n        mini_sectors = np.linspace(0, 1, num_minisectors)\n        dominance_stats = {driver: 0 for driver in drivers}\n        \n        for i in range(num_minisectors - 1):\n            fastest_driver = None\n            fastest_speed = -1\n            fastest_sector_data = None\n            \n            # Find fastest driver in this mini-sector\n            for driver, tel in driver_telemetry.items():\n                # Use higher resolution data for smoother sectors\n                sector_size = len(tel['Distance']) // num_minisectors\n                start_idx = i * sector_size\n                end_idx = min((i + 1) * sector_size, len(tel['Distance']))\n                \n                if start_idx >= end_idx:\n                    continue\n                \n                mean_speed = np.mean(tel['Speed'][start_idx:end_idx])\n                \n                if mean_speed > fastest_speed:\n                    fastest_speed = mean_speed\n                    fastest_driver = driver\n                    fastest_sector_data = {\n                        'X': tel['X'][start_idx:end_idx],\n                        'Y': tel['Y'][start_idx:end_idx]\n                    }\n            \n            # Plot the fastest sector with enhanced styling\n            if fastest_sector_data is not None and fastest_driver is not None:\n                dominance_stats[fastest_driver] += 1\n                team = DRIVER_TEAMS.get(fastest_driver, 'Unknown')\n                color = TEAM_COLORS.get(team, '#FFFFFF')\n                \n                fig.add_trace(go.Scatter(\n                    x=fastest_sector_data['X'],\n                    y=fastest_sector_data['Y'],\n                    mode='lines',\n                    line=dict(\n                        color=color, \n                        width=8,\n                        shape='spline',\n                        smoothing=1.3\n                    ),\n                    name=fastest_driver,\n                    showlegend=False,\n                    opacity=0.95,\n                    hovertemplate=f\"<b>{fastest_driver}</b><br>Average Speed: {fastest_speed:.1f} km/h<br>Sector: {i+1}/{num_minisectors}<extra></extra>\"\n                ))\n        \n        # Show track outline if requested\n        if show_track_outline:\n            # Use first driver's track coordinates for outline\n            first_driver = list(driver_telemetry.keys())[0]\n            outline_data = driver_telemetry[first_driver]\n            \n            fig.add_trace(go.Scatter(\n                x=outline_data['X'],\n                y=outline_data['Y'],\n                mode='lines',\n                line=dict(color='rgba(255,255,255,0.3)', width=1),\n                name='Track Outline',\n                showlegend=False,\n                hoverinfo='skip'\n            ))\n        \n        # Add enhanced legend with dominance statistics\n        legend_traces = []\n        for driver in drivers:\n            if driver in driver_telemetry:\n                team = DRIVER_TEAMS.get(driver, 'Unknown')\n                color = TEAM_COLORS.get(team, '#FFFFFF')\n                dominance_pct = (dominance_stats[driver] / num_minisectors) * 100\n                lap_time = driver_lap_times.get(driver, 0)\n                \n                # Format lap time\n                if lap_time != float('inf') and lap_time > 0:\n                    minutes = int(lap_time // 60)\n                    seconds = lap_time % 60\n                    lap_time_str = f\"{minutes}:{seconds:06.3f}\"\n                else:\n                    lap_time_str = \"N/A\"\n                \n                legend_traces.append(go.Scatter(\n                    x=[None], y=[None],\n                    mode='lines',\n                    line=dict(color=color, width=8),\n                    name=f\"{driver} - {dominance_pct:.1f}% | {lap_time_str}\",\n                    showlegend=True\n                ))\n        \n        # Add legend traces\n        for trace in legend_traces:\n            fig.add_trace(trace)\n        \n        fig.update_layout(\n            title={\n                'text': f\"🗺️ Track Dominance Map<br><sub>Fastest Mini-Sectors Analysis ({num_minisectors} sectors)</sub>\",\n                'x': 0.5,\n                'xanchor': 'center',\n                'font': {'size': 24, 'color': 'white'}\n            },\n            xaxis=dict(\n                showgrid=False,\n                showticklabels=False,\n                zeroline=False,\n                scaleanchor=\"y\",\n                scaleratio=1,\n                visible=False\n            ),\n            yaxis=dict(\n                showgrid=False,\n                showticklabels=False,\n                zeroline=False,\n                visible=False\n            ),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white',\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=0.98,\n                xanchor=\"left\",\n                x=0.02,\n                bgcolor='rgba(24, 25, 26, 0.8)',\n                bordercolor='rgba(0, 210, 190, 0.3)',\n                borderwidth=1,\n                font=dict(size=12, family='Inter')\n            ),\n            showlegend=True,\n            hovermode='closest',\n            annotations=[\n                dict(\n                    x=0.98, y=0.02,\n                    xref=\"paper\", yref=\"paper\",\n                    text=\"Dominance % | Fastest Lap Time\",\n                    showarrow=False,\n                    font=dict(size=10, color='rgba(255,255,255,0.6)'),\n                    align=\"right\"\n                )\n            ],\n            margin=dict(l=10, r=10, t=60, b=10)\n        )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating track dominance map: {str(e)}\")\n        return None\n\ndef create_speed_heatmap(data_loader, driver):\n    \"\"\"Create speed heatmap for a single driver\"\"\"\n    try:\n        telemetry = data_loader.get_driver_telemetry(driver)\n        \n        if telemetry is None or telemetry.empty:\n            return None\n        \n        if 'X' not in telemetry.columns or 'Y' not in telemetry.columns or 'Speed' not in telemetry.columns:\n            return None\n        \n        fig = go.Figure()\n        \n        # Create speed-colored track\n        fig.add_trace(go.Scatter(\n            x=telemetry['X'],\n            y=telemetry['Y'],\n            mode='markers',\n            marker=dict(\n                size=4,\n                color=telemetry['Speed'],\n                colorscale='Viridis',\n                showscale=True,\n                colorbar=dict(title=\"Speed (km/h)\")\n            ),\n            name=f\"{driver} Speed\",\n            hovertemplate=f\"<b>{driver}</b><br>Speed: %{{marker.color:.1f}} km/h<extra></extra>\"\n        ))\n        \n        team = DRIVER_TEAMS.get(driver, 'Unknown')\n        \n        fig.update_layout(\n            title=f\"Speed Heatmap - {driver} ({team})\",\n            xaxis=dict(\n                showgrid=False,\n                showticklabels=False,\n                zeroline=False,\n                scaleanchor=\"y\",\n                scaleratio=1\n            ),\n            yaxis=dict(\n                showgrid=False,\n                showticklabels=False,\n                zeroline=False\n            ),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white'\n        )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating speed heatmap: {str(e)}\")\n        return None\n","size_bytes":12128},"utils/visualizations.py":{"content":"\"\"\"\nVisualization utilities for F1 data analysis\n\"\"\"\n\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport pandas as pd\nimport numpy as np\nimport streamlit as st\nfrom .constants import TEAM_COLORS, DRIVER_TEAMS, TIRE_COLORS\n\ndef create_telemetry_plot(data_loader, drivers, telemetry_type='speed'):\n    \"\"\"Create telemetry comparison plot\"\"\"\n    if not drivers:\n        return None\n    \n    try:\n        telemetry_data = data_loader.get_fastest_lap_telemetry(drivers)\n        \n        if not telemetry_data:\n            return None\n        \n        fig = go.Figure()\n        \n        # Initialize y_title based on telemetry_type\n        y_title_map = {\n            'speed': 'Speed (km/h)',\n            'throttle': 'Throttle (%)',\n            'brake': 'Brake Pressure',\n            'rpm': 'Engine RPM',\n            'gear': 'Gear'\n        }\n        y_title = y_title_map.get(telemetry_type.lower(), telemetry_type.title())\n        \n        for driver in drivers:\n            if driver not in telemetry_data:\n                continue\n                \n            telemetry = telemetry_data[driver]\n            \n            if telemetry_type.lower() == 'speed' and 'Speed' in telemetry.columns:\n                y_data = telemetry['Speed']\n            elif telemetry_type.lower() == 'throttle' and 'Throttle' in telemetry.columns:\n                y_data = telemetry['Throttle']\n            elif telemetry_type.lower() == 'brake' and 'Brake' in telemetry.columns:\n                y_data = telemetry['Brake']\n            elif telemetry_type.lower() == 'rpm' and 'RPM' in telemetry.columns:\n                y_data = telemetry['RPM']\n            elif telemetry_type.lower() == 'gear' and 'nGear' in telemetry.columns:\n                y_data = telemetry['nGear']\n            else:\n                continue\n            \n            team = DRIVER_TEAMS.get(driver, 'Unknown')\n            color = TEAM_COLORS.get(team, '#FFFFFF')\n            \n            fig.add_trace(go.Scatter(\n                x=telemetry['Distance'] if 'Distance' in telemetry.columns else range(len(y_data)),\n                y=y_data,\n                mode='lines',\n                name=f\"{driver} ({team})\",\n                line=dict(color=color, width=3),\n                hovertemplate=f\"<b>{driver}</b><br>Distance: %{{x:.0f}}m<br>{y_title}: %{{y:.1f}}<extra></extra>\"\n            ))\n        \n        # y_title is already defined above\n            \n        fig.update_layout(\n            title=f\"{telemetry_type.title()} Comparison - Fastest Laps\",\n            xaxis_title=\"Distance (m)\" if any('Distance' in telemetry_data[d].columns for d in telemetry_data) else \"Data Points\",\n            yaxis_title=y_title,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white',\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            ),\n            hovermode='x unified'\n        )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating telemetry plot: {str(e)}\")\n        return None\n\ndef create_tire_strategy_plot(data_loader, drivers):\n    \"\"\"Create tire strategy visualization\"\"\"\n    try:\n        tire_data = data_loader.get_tire_data(drivers)\n        \n        if tire_data is None or tire_data.empty:\n            return None\n        \n        fig = go.Figure()\n        \n        y_pos = 0\n        for driver in drivers:\n            driver_data = tire_data[tire_data['Driver'] == driver]\n            if driver_data.empty:\n                continue\n            \n            # Group consecutive laps with same compound\n            stints = []\n            current_compound = None\n            stint_start = None\n            prev_lap_num = None\n            \n            for _, lap in driver_data.iterrows():\n                if current_compound != lap['Compound']:\n                    if current_compound is not None and prev_lap_num is not None:\n                        stints.append({\n                            'compound': current_compound,\n                            'start_lap': stint_start,\n                            'end_lap': prev_lap_num,\n                            'laps': prev_lap_num - stint_start + 1\n                        })\n                    current_compound = lap['Compound']\n                    stint_start = lap['LapNumber']\n                prev_lap_num = lap['LapNumber']\n            \n            # Add final stint\n            if current_compound is not None and prev_lap_num is not None:\n                stints.append({\n                    'compound': current_compound,\n                    'start_lap': stint_start,\n                    'end_lap': prev_lap_num,\n                    'laps': prev_lap_num - stint_start + 1\n                })\n            \n            # Plot stints with enhanced styling\n            team = DRIVER_TEAMS.get(driver, 'Unknown')\n            team_color = TEAM_COLORS.get(team, '#FFFFFF')\n            \n            for i, stint in enumerate(stints):\n                tire_color = TIRE_COLORS.get(stint['compound'], '#808080')\n                \n                # Create gradient effect by varying opacity\n                opacity = 0.8 if i % 2 == 0 else 0.9\n                \n                fig.add_trace(go.Bar(\n                    x=[stint['laps']],\n                    y=[driver],\n                    orientation='h',\n                    name=f\"{driver} - {stint['compound']}\",\n                    marker=dict(\n                        color=tire_color,\n                        opacity=opacity,\n                        line=dict(color=team_color, width=2)\n                    ),\n                    base=stint['start_lap'] - 1,\n                    hovertemplate=(\n                        f\"<b>{driver}</b> ({team})<br>\"\n                        f\"Compound: {stint['compound']}<br>\"\n                        f\"Laps: {stint['start_lap']}-{stint['end_lap']}<br>\"\n                        f\"Stint Length: {stint['laps']} laps\"\n                        \"<extra></extra>\"\n                    ),\n                    showlegend=False\n                ))\n                \n                # Add stint length annotation\n                fig.add_annotation(\n                    x=stint['start_lap'] + stint['laps']/2 - 1,\n                    y=y_pos,\n                    text=str(stint['laps']),\n                    showarrow=False,\n                    font=dict(color=\"white\", size=10, family=\"monospace\")\n                )\n            \n            y_pos += 1\n        \n        # Add compound legend\n        compounds_used = tire_data['Compound'].unique()\n        for compound in compounds_used:\n            if compound in TIRE_COLORS:\n                fig.add_trace(go.Scatter(\n                    x=[None], y=[None],\n                    mode='markers',\n                    marker=dict(size=15, color=TIRE_COLORS[compound], symbol='square'),\n                    name=compound,\n                    showlegend=True\n                ))\n        \n        fig.update_layout(\n            title=\"Enhanced Tire Strategy Analysis\",\n            xaxis_title=\"Lap Number\",\n            yaxis_title=\"Driver\",\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white',\n            barmode='overlay',\n            height=500,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1,\n                bgcolor=\"rgba(0,0,0,0.5)\",\n                bordercolor=\"rgba(255,255,255,0.2)\",\n                borderwidth=1\n            ),\n            hovermode='closest'\n        )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating tire strategy plot: {str(e)}\")\n        return None\n\ndef create_race_progression_plot(data_loader, drivers):\n    \"\"\"Create professional race progression visualization with enhanced features\"\"\"\n    try:\n        position_data = data_loader.get_position_data(drivers)\n        \n        if position_data is None or position_data.empty:\n            return None\n        \n        fig = go.Figure()\n        \n        # Add background grid for better readability\n        max_laps = int(position_data['LapNumber'].max())\n        max_pos = int(position_data['Position'].max())\n        \n        # Create enhanced traces for each driver\n        for driver in drivers:\n            driver_data = position_data[position_data['Driver'] == driver].sort_values('LapNumber')\n            if driver_data.empty:\n                continue\n            \n            team = DRIVER_TEAMS.get(driver, 'Unknown')\n            color = TEAM_COLORS.get(team, '#FFFFFF')\n            \n            # Get position changes for annotations\n            start_pos = int(driver_data['Position'].iloc[0])\n            end_pos = int(driver_data['Position'].iloc[-1])\n            position_change = start_pos - end_pos\n            \n            # Create smooth line with markers\n            fig.add_trace(go.Scatter(\n                x=driver_data['LapNumber'],\n                y=driver_data['Position'],\n                mode='lines+markers',\n                name=f\"{driver} (P{start_pos}→P{end_pos})\",\n                line=dict(\n                    color=color, \n                    width=4,\n                    shape='spline',\n                    smoothing=1.0\n                ),\n                marker=dict(\n                    size=8, \n                    color=color,\n                    line=dict(width=2, color='white')\n                ),\n                fill=None,\n                connectgaps=True,\n                hovertemplate=f\"\"\"\n                <b>{driver} ({team})</b><br>\n                Lap: %{{x}}<br>\n                Position: P%{{y}}<br>\n                <extra></extra>\n                \"\"\"\n            ))\n            \n            # Add start/finish position annotations\n            fig.add_annotation(\n                x=driver_data['LapNumber'].iloc[0],\n                y=start_pos,\n                text=f\"P{start_pos}\",\n                showarrow=True,\n                arrowhead=2,\n                arrowsize=1,\n                arrowwidth=2,\n                arrowcolor=color,\n                font=dict(size=10, color=color),\n                bgcolor=\"rgba(0,0,0,0.7)\",\n                bordercolor=color,\n                borderwidth=1\n            )\n            \n            fig.add_annotation(\n                x=driver_data['LapNumber'].iloc[-1],\n                y=end_pos,\n                text=f\"P{end_pos}\",\n                showarrow=True,\n                arrowhead=2,\n                arrowsize=1,\n                arrowwidth=2,\n                arrowcolor=color,\n                font=dict(size=10, color=color),\n                bgcolor=\"rgba(0,0,0,0.7)\",\n                bordercolor=color,\n                borderwidth=1\n            )\n        \n        # Enhanced layout with professional styling\n        fig.update_layout(\n            title={\n                'text': \"📊 Race Progression Analysis<br><sub>Position Changes Throughout the Race</sub>\",\n                'x': 0.5,\n                'xanchor': 'center',\n                'font': {'size': 24, 'color': 'white'}\n            },\n            xaxis=dict(\n                title=\"Lap Number\",\n                showgrid=True,\n                gridwidth=1,\n                gridcolor='rgba(255,255,255,0.1)',\n                range=[0, max_laps + 2],\n                dtick=5,\n                title_font=dict(size=14, color='white'),\n                tickfont=dict(size=12, color='white')\n            ),\n            yaxis=dict(\n                title=\"Track Position\",\n                showgrid=True,\n                gridwidth=1,\n                gridcolor='rgba(255,255,255,0.1)',\n                autorange='reversed',  # Reverse so P1 is at top\n                dtick=1,\n                range=[max_pos + 0.5, 0.5],\n                title_font=dict(size=14, color='white'),\n                tickfont=dict(size=12, color='white')\n            ),\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white',\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=0.98,\n                xanchor=\"left\",\n                x=0.02,\n                bgcolor='rgba(24, 25, 26, 0.8)',\n                bordercolor='rgba(0, 210, 190, 0.3)',\n                borderwidth=1,\n                font=dict(size=11)\n            ),\n            hovermode='x unified',\n            margin=dict(l=60, r=20, t=80, b=60)\n        )\n        \n        # Add position lines for reference\n        for pos in range(1, min(max_pos + 1, 21)):  # Only show up to P20\n            fig.add_shape(\n                type=\"line\",\n                x0=0, y0=pos, x1=max_laps, y1=pos,\n                line=dict(\n                    color=\"rgba(255,255,255,0.05)\",\n                    width=1,\n                    dash=\"dot\"\n                )\n            )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating race progression plot: {str(e)}\")\n        return None\n\ndef create_sector_comparison_plot(data_loader, drivers):\n    \"\"\"Create sector time comparison plot\"\"\"\n    try:\n        lap_data = data_loader.get_lap_comparison(drivers)\n        \n        if lap_data is None or lap_data.empty:\n            return None\n        \n        # Get fastest lap for each driver\n        fastest_laps = lap_data.loc[lap_data.groupby('Driver')['LapTime_seconds'].idxmin()]\n        \n        sectors = ['Sector1Time', 'Sector2Time', 'Sector3Time']\n        sector_data = []\n        \n        for _, lap in fastest_laps.iterrows():\n            driver = lap['Driver']\n            team = DRIVER_TEAMS.get(driver, 'Unknown')\n            \n            for i, sector in enumerate(sectors, 1):\n                if pd.notna(lap[sector]) and hasattr(lap[sector], 'total_seconds'):\n                    sector_data.append({\n                        'Driver': driver,\n                        'Team': team,\n                        'Sector': f'S{i}',\n                        'Time': lap[sector].total_seconds()\n                    })\n        \n        if not sector_data:\n            return None\n        \n        sector_df = pd.DataFrame(sector_data)\n        \n        fig = px.bar(\n            sector_df,\n            x='Sector',\n            y='Time',\n            color='Driver',\n            color_discrete_map={\n                driver: TEAM_COLORS.get(DRIVER_TEAMS.get(driver, 'Unknown'), '#FFFFFF')\n                for driver in drivers\n            },\n            title=\"Sector Time Comparison - Fastest Laps\",\n            labels={'Time': 'Sector Time (seconds)'},\n            barmode='group'\n        )\n        \n        fig.update_layout(\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font_color='white'\n        )\n        \n        return fig\n        \n    except Exception as e:\n        st.error(f\"Error creating sector comparison plot: {str(e)}\")\n        return None\n","size_bytes":15164},"utils/weather_analytics.py":{"content":"\"\"\"\nWeather Analytics Module for F1 Data Analysis\nProvides weather impact analysis and track condition insights\n\"\"\"\n\nimport fastf1\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nclass WeatherAnalytics:\n    \"\"\"Weather analysis for F1 sessions\"\"\"\n    \n    def __init__(self, session):\n        self.session = session\n        self.weather_data = session.weather_data if hasattr(session, 'weather_data') else None\n        self.laps = session.laps\n        \n    def get_weather_summary(self):\n        \"\"\"Get comprehensive weather summary for the session\"\"\"\n        if self.weather_data is None or self.weather_data.empty:\n            return self._get_basic_weather_info()\n            \n        summary = {\n            'air_temperature': {\n                'min': self.weather_data['AirTemp'].min(),\n                'max': self.weather_data['AirTemp'].max(),\n                'mean': self.weather_data['AirTemp'].mean(),\n            },\n            'track_temperature': {\n                'min': self.weather_data['TrackTemp'].min(),\n                'max': self.weather_data['TrackTemp'].max(),\n                'mean': self.weather_data['TrackTemp'].mean(),\n            },\n            'humidity': {\n                'min': self.weather_data['Humidity'].min(),\n                'max': self.weather_data['Humidity'].max(),\n                'mean': self.weather_data['Humidity'].mean(),\n            },\n            'wind_speed': {\n                'min': self.weather_data['WindSpeed'].min(),\n                'max': self.weather_data['WindSpeed'].max(),\n                'mean': self.weather_data['WindSpeed'].mean(),\n            },\n            'pressure': {\n                'min': self.weather_data['Pressure'].min(),\n                'max': self.weather_data['Pressure'].max(),\n                'mean': self.weather_data['Pressure'].mean(),\n            },\n            'rainfall': self.weather_data['Rainfall'].any() if 'Rainfall' in self.weather_data.columns else False\n        }\n        \n        return summary\n    \n    def _get_basic_weather_info(self):\n        \"\"\"Get basic weather info from lap data if weather_data is not available\"\"\"\n        # Try to extract weather info from laps data\n        weather_info = {}\n        \n        # Get unique weather conditions if available\n        if 'TrackStatus' in self.laps.columns:\n            track_conditions = self.laps['TrackStatus'].value_counts().to_dict()\n            weather_info['track_conditions'] = track_conditions\n            \n        if 'IsPersonalBest' in self.laps.columns:\n            # Analyze performance trends which might indicate weather impact\n            weather_info['performance_trend'] = 'stable'\n            \n        return weather_info\n    \n    def analyze_weather_impact_on_lap_times(self):\n        \"\"\"Analyze how weather conditions affect lap times\"\"\"\n        if self.weather_data is None or self.weather_data.empty:\n            return None\n            \n        # Merge weather data with lap data\n        weather_impact = []\n        \n        for idx, weather_row in self.weather_data.iterrows():\n            # Find laps that occurred during this weather measurement\n            session_time = weather_row['Time']\n            \n            # Get laps around this time (within 1 minute)\n            time_window_laps = self.laps[\n                (self.laps['Time'] >= session_time - pd.Timedelta(minutes=1)) &\n                (self.laps['Time'] <= session_time + pd.Timedelta(minutes=1))\n            ]\n            \n            if not time_window_laps.empty:\n                avg_lap_time = time_window_laps['LapTime'].mean()\n                \n                weather_impact.append({\n                    'time': session_time,\n                    'air_temp': weather_row['AirTemp'],\n                    'track_temp': weather_row['TrackTemp'],\n                    'humidity': weather_row['Humidity'],\n                    'wind_speed': weather_row['WindSpeed'],\n                    'pressure': weather_row['Pressure'],\n                    'average_lap_time': avg_lap_time.total_seconds() if pd.notna(avg_lap_time) else None,\n                    'lap_count': len(time_window_laps)\n                })\n        \n        return pd.DataFrame(weather_impact)\n    \n    def create_weather_evolution_plot(self):\n        \"\"\"Create a plot showing weather evolution during the session\"\"\"\n        if self.weather_data is None or self.weather_data.empty:\n            return self._create_basic_weather_plot()\n            \n        fig = make_subplots(\n            rows=4, cols=1,\n            subplot_titles=[\n                'Temperature Evolution (°C)',\n                'Humidity and Pressure',\n                'Wind Conditions',\n                'Track Conditions'\n            ],\n            vertical_spacing=0.08\n        )\n        \n        # Temperature plot\n        fig.add_trace(go.Scatter(\n            x=self.weather_data.index,\n            y=self.weather_data['AirTemp'],\n            name='Air Temperature',\n            line=dict(color='#FF6B6B', width=2)\n        ), row=1, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=self.weather_data.index,\n            y=self.weather_data['TrackTemp'],\n            name='Track Temperature',\n            line=dict(color='#4ECDC4', width=2)\n        ), row=1, col=1)\n        \n        # Humidity and Pressure\n        fig.add_trace(go.Scatter(\n            x=self.weather_data.index,\n            y=self.weather_data['Humidity'],\n            name='Humidity (%)',\n            line=dict(color='#45B7D1', width=2),\n            yaxis='y2'\n        ), row=2, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=self.weather_data.index,\n            y=self.weather_data['Pressure'],\n            name='Pressure (mbar)',\n            line=dict(color='#96CEB4', width=2)\n        ), row=2, col=1)\n        \n        # Wind conditions\n        fig.add_trace(go.Scatter(\n            x=self.weather_data.index,\n            y=self.weather_data['WindSpeed'],\n            name='Wind Speed (km/h)',\n            line=dict(color='#FFEAA7', width=2)\n        ), row=3, col=1)\n        \n        if 'WindDirection' in self.weather_data.columns:\n            fig.add_trace(go.Scatter(\n                x=self.weather_data.index,\n                y=self.weather_data['WindDirection'],\n                name='Wind Direction (°)',\n                line=dict(color='#DDA0DD', width=2),\n                yaxis='y4'\n            ), row=3, col=1)\n        \n        # Track conditions (if rainfall data exists)\n        if 'Rainfall' in self.weather_data.columns:\n            fig.add_trace(go.Bar(\n                x=self.weather_data.index,\n                y=self.weather_data['Rainfall'].astype(int),\n                name='Rainfall',\n                marker_color='#74B9FF',\n                opacity=0.7\n            ), row=4, col=1)\n        \n        fig.update_layout(\n            height=800,\n            title='Weather Evolution During Session',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            showlegend=True\n        )\n        \n        # Update axes\n        for i in range(1, 5):\n            fig.update_xaxes(\n                title_text='Session Time' if i == 4 else '',\n                gridcolor='rgba(255,255,255,0.1)',\n                row=i, col=1\n            )\n            fig.update_yaxes(\n                gridcolor='rgba(255,255,255,0.1)',\n                row=i, col=1\n            )\n        \n        return fig\n    \n    def _create_basic_weather_plot(self):\n        \"\"\"Create basic weather info plot when detailed data is not available\"\"\"\n        fig = go.Figure()\n        \n        fig.add_annotation(\n            x=0.5, y=0.5,\n            text=\"Detailed weather data not available for this session.<br>Weather impact analysis requires live session data.\",\n            showarrow=False,\n            font=dict(size=16, color='white'),\n            align='center'\n        )\n        \n        fig.update_layout(\n            title='Weather Information',\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)',\n            font=dict(color='white'),\n            showlegend=False,\n            height=400\n        )\n        \n        return fig\n    \n    def get_optimal_conditions_analysis(self):\n        \"\"\"Analyze optimal weather conditions for fastest lap times\"\"\"\n        weather_impact_data = self.analyze_weather_impact_on_lap_times()\n        \n        if weather_impact_data is None or weather_impact_data.empty:\n            return None\n            \n        # Filter out invalid lap times\n        valid_data = weather_impact_data[weather_impact_data['average_lap_time'].notna()]\n        \n        if valid_data.empty:\n            return None\n            \n        # Find conditions for fastest average lap times\n        fastest_conditions_idx = valid_data['average_lap_time'].idxmin()\n        fastest_conditions = valid_data.iloc[fastest_conditions_idx]\n        \n        # Calculate correlations\n        correlations = {}\n        lap_time_series = pd.Series(valid_data['average_lap_time'])\n        for weather_param in ['air_temp', 'track_temp', 'humidity', 'wind_speed', 'pressure']:\n            if weather_param in valid_data.columns:\n                weather_series = pd.Series(valid_data[weather_param])\n                correlation = lap_time_series.corr(weather_series)\n                correlations[weather_param] = correlation\n        \n        return {\n            'optimal_conditions': fastest_conditions.to_dict(),\n            'correlations': correlations,\n            'total_samples': len(valid_data)\n        }","size_bytes":9650}},"version":1}